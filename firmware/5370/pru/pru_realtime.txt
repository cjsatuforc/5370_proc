Source File 1 : 'pru_realtime.p' (368 Instructions Generated)

    1 :                   : //
    2 :                   : // Code that runs on the PRU to count overflows of the N0/N3 hardware registers and
    3 :                   : // perform 5370 bus cycles.
    4 :                   : //
    5 :                   : 
    6 :                   : .origin 0
    7 :                   : .entrypoint start
    8 :                   : 
    9 :                   : #include "pru_realtime.hp"
   10 :                   : 
   11 :                   : 	// shared memory used to communicate with CPU
   12 :                   : 	// layout must match pru_realtime.h
   13 :                   : 	.struct	m
   14 :                   : 		.u32	cmd
   15 :                   : 		.u32	count
   16 :                   : 		.u32	watchdog
   17 :                   : 		
   18 :                   : 		.u32	p0
   19 :                   : 		.u32	p1
   20 :                   : 		.u32	p2
   21 :                   : 		.u32	p3
   22 :                   : 
   23 :                   : 		.u32	n0_ovfl					// overflow counts
   24 :                   : 		.u32	n3_ovfl
   25 :                   : 		.u32	ovfl_none
   26 :                   : 
   27 :                   : 		.u32	a_gen_0				// pre-scrambled address for general bus i/o
   28 :                   : 		.u32	a_gen_0c
   29 :                   : 		.u32	a_gen_1
   30 :                   : 		.u32	a_gen_1c
   31 :                   : 		.u32	a_gen_3
   32 :                   : 		.u32	a_gen_3c
   33 :                   : 
   34 :                   : 		.u32	a_n0st_0				// pre-scrambled RREG_N0ST address
   35 :                   : 		.u32	a_n0st_0c
   36 :                   : 		.u32	a_n0st_1
   37 :                   : 		.u32	a_n0st_1c
   38 :                   : 		.u32	a_n0st_3
   39 :                   : 		.u32	a_n0st_3c
   40 :                   : 
   41 :                   : 		.u32	a_n0_h_0
   42 :                   : 		.u32	a_n0_h_0c
   43 :                   : 		.u32	a_n0_h_1
   44 :                   : 		.u32	a_n0_h_1c
   45 :                   : 		.u32	a_n0_h_3
   46 :                   : 		.u32	a_n0_h_3c
   47 :                   : 
   48 :                   : 		.u32	a_n1n2_h_0
   49 :                   : 		.u32	a_n1n2_h_0c
   50 :                   : 		.u32	a_n1n2_h_1
   51 :                   : 		.u32	a_n1n2_h_1c
   52 :                   : 		.u32	a_n1n2_h_3
   53 :                   : 		.u32	a_n1n2_h_3c
   54 :                   : 
   55 :                   : 		.u32	a_o3_0					// pre-scrambled RREG_O3 address
   56 :                   : 		.u32	a_o3_0c
   57 :                   : 		.u32	a_o3_1
   58 :                   : 		.u32	a_o3_1c
   59 :                   : 		.u32	a_o3_3
   60 :                   : 		.u32	a_o3_3c
   61 :                   : 
   62 :                   : 		.u32	d_n0_clr_ovfl_0			// pre-scrambled WREG_O3_N0_CLR_OVFL data
   63 :                   : 		.u32	d_n0_clr_ovfl_0c
   64 :                   : 		.u32	d_n0_clr_ovfl_1
   65 :                   : 		.u32	d_n0_clr_ovfl_1c
   66 :                   : 		.u32	d_n0_clr_ovfl_2
   67 :                   : 		.u32	d_n0_clr_ovfl_2c
   68 :                   : 
   69 :                   : 		.u32	d_n3_clr_ovfl_0			// pre-scrambled WREG_O3_N3_CLR_OVFL data
   70 :                   : 		.u32	d_n3_clr_ovfl_0c
   71 :                   : 		.u32	d_n3_clr_ovfl_1
   72 :                   : 		.u32	d_n3_clr_ovfl_1c
   73 :                   : 		.u32	d_n3_clr_ovfl_2
   74 :                   : 		.u32	d_n3_clr_ovfl_2c
   75 :                   : 	.ends
   76 :                   : 
   77 :                   : 	.struct	m2
   78 :                   : 		.u32	m2_offset
   79 :                   : 		
   80 :                   : 		.u32	d_gen_0				// pre/post-scrambled read/write data for general bus i/o
   81 :                   : 		.u32	d_gen_0c
   82 :                   : 		.u32	d_gen_1
   83 :                   : 		.u32	d_gen_1c
   84 :                   : 		.u32	d_gen_2
   85 :                   : 		.u32	d_gen_2c
   86 :                   : 
   87 :                   : 		// rest are for PRU_TI_MEAS
   88 :                   : 		.u32	ad_rst_0
   89 :                   : 		.u32	ad_rst_0c
   90 :                   : 		.u32	ad_rst_1
   91 :                   : 		.u32	ad_rst_1c
   92 :                   : 		.u32	ad_rst_2
   93 :                   : 		.u32	ad_rst_2c
   94 :                   : 		.u32	ad_rst_3
   95 :                   : 		.u32	ad_rst_3c
   96 :                   : 
   97 :                   : 		.u32	ad_ena_0
   98 :                   : 		.u32	ad_ena_0c
   99 :                   : 		.u32	ad_ena_1
  100 :                   : 		.u32	ad_ena_1c
  101 :                   : 		.u32	ad_ena_2
  102 :                   : 		.u32	ad_ena_2c
  103 :                   : 		.u32	ad_ena_3
  104 :                   : 		.u32	ad_ena_3c
  105 :                   : 
  106 :                   : 		.u32	ad_arm_0
  107 :                   : 		.u32	ad_arm_0c
  108 :                   : 		.u32	ad_arm_1
  109 :                   : 		.u32	ad_arm_1c
  110 :                   : 		.u32	ad_arm_2
  111 :                   : 		.u32	ad_arm_2c
  112 :                   : 		.u32	ad_arm_3
  113 :                   : 		.u32	ad_arm_3c
  114 :                   : 
  115 :                   : 		.u32	ad_idle_0
  116 :                   : 		.u32	ad_idle_0c
  117 :                   : 		.u32	ad_idle_1
  118 :                   : 		.u32	ad_idle_1c
  119 :                   : 		.u32	ad_idle_2
  120 :                   : 		.u32	ad_idle_2c
  121 :                   : 		.u32	ad_idle_3
  122 :                   : 		.u32	ad_idle_3c
  123 :                   : 
  124 :                   : 		.u32	d_n0st_0
  125 :                   : 		.u32	d_n0st_1
  126 :                   : 		.u32	d_n0st_2
  127 :                   : 
  128 :                   : 		.u32	d_n1n2_h_0
  129 :                   : 		.u32	d_n1n2_h_1
  130 :                   : 		.u32	d_n1n2_h_2
  131 :                   : 
  132 :                   : 		.u32	d_n1n2_l_0
  133 :                   : 		.u32	d_n1n2_l_1
  134 :                   : 		.u32	d_n1n2_l_2
  135 :                   : 
  136 :                   : 		.u32	d_n0_h_0
  137 :                   : 		.u32	d_n0_h_1
  138 :                   : 		.u32	d_n0_h_2
  139 :                   : 
  140 :                   : 		.u32	d_n0_l_0
  141 :                   : 		.u32	d_n0_l_1
  142 :                   : 		.u32	d_n0_l_2
  143 :                   : 	.ends
  144 :                   : 
  145 :                   : 	// register aliases
  146 :                   : 	.struct	regs
  147 :                   : 		.u32	m
  148 :                   : 		.u32	m2
  149 :                   : 		.u32	gpio0
  150 :                   : 		.u32	gpio1
  151 :                   : 		.u32	gpio2
  152 :                   : 		.u32	gpio3
  153 :                   : 		.u32	gpio_in
  154 :                   : 		.u32	gpio_oe
  155 :                   : 		.u32	gpio_set
  156 :                   : 		.u32	gpio_clr
  157 :                   : 		.u32	timer
  158 :                   : 		.u32	timer_tclr
  159 :                   : 		.u32	timer_tcrr
  160 :                   : 		.u32	p0
  161 :                   : 		.u32	p1
  162 :                   : 		.u32	p2
  163 :                   : 		.u32	p3
  164 :                   : 		.u32	p4
  165 :                   : 		.u32	p5
  166 :                   : 		.u32	n0_ovfl
  167 :                   : 		.u32	n3_ovfl
  168 :                   : 		.u32	ovfl_none
  169 :                   : 		.u16	ra1
  170 :                   : 		.u16	ra2
  171 :                   : 		.u16	ra3
  172 :                   : 		.u16	ra4
  173 :                   : 		.u32	io30
  174 :                   : 		.u32	io31
  175 :                   : 	.ends
  176 :                   : 	
  177 :                   : 	.assign	regs, r6, r31, r			// r0-r5 are temps, avoid r30-r31
  178 :                   : 
  179 :                   : start:
  180 :                   :     // enable OCP master ports so we can access gpio & timer
  181 : 0x0000 0x91042481 :     lbco	r1, c4, 4, 4				// SYSCFG register (C4 in constant table)
  182 : 0x0001 0x1d04e1e1 :     clr		r1, r1, 4					// clear standby_init bit
  183 : 0x0002 0x81042481 :     sbco	r1, c4, 4, 4
  184 :                   : 
  185 :                   : 	// address pointers (too big for immediate field in most cases)
  186 : 0x0003 0x240000e6 : 	mov		r.m, PRU_COM_MEM
  187 : 0x0004 0x240100e7 : 	mov		r.m2, PRU_COM_MEM2
  188 : 0x0005 0x2444e0c8 : 	mov		r.gpio0, GPIO0_BASE
      : 0x0006 0x24700088 : 
  189 : 0x0007 0x244804c9 : 	mov		r.gpio1, GPIO1_BASE
      : 0x0008 0x24c00089 : 
  190 : 0x0009 0x24481aca : 	mov		r.gpio2, GPIO2_BASE
      : 0x000a 0x24c0008a : 
  191 : 0x000b 0x24481acb : 	mov		r.gpio3, GPIO3_BASE
      : 0x000c 0x24e0008b : 
  192 : 0x000d 0x240138ec : 	mov		r.gpio_in, _GPIO_IN
  193 : 0x000e 0x240134ed : 	mov		r.gpio_oe, _GPIO_OE
  194 : 0x000f 0x240194ee : 	mov		r.gpio_set, _GPIO_SET
  195 : 0x0010 0x240190ef : 	mov		r.gpio_clr, _GPIO_CLR
  196 : 0x0011 0x244804d0 : 	mov		r.timer, TIMER4_BASE
      : 0x0012 0x24400090 : 
  197 : 0x0013 0x240038f1 : 	mov		r.timer_tclr, _TIMER_TCLR
  198 : 0x0014 0x24003cf2 : 	mov		r.timer_tcrr, _TIMER_TCRR
  199 :                   : 
  200 : 0x0015 0x240000e1 : 	mov		r1, 0
  201 : 0x0016 0xe1082681 : 	eput	r1, r.m, m.watchdog
  202 : 0x0017 0x21003d00 : 	jmp		cmd_clear
  203 :                   : 
  204 :                   : cmd_done:
  205 : 0x0018 0x240000e1 : 	mov		r1, PRU_DONE
  206 : 0x0019 0xe1002681 :     eput	r1, r.m, m.cmd
  207 :                   :     
  208 :                   : cmd_get:
  209 : 0x001a 0xf1002681 : 	eget	r1, r.m, m.cmd
  210 : 0x001b 0x5101e10a : 	qbeq	cmd_ping, r1, PRU_PING
  211 : 0x001c 0x5102e110 : 	qbeq	cmd_read, r1, PRU_READ
  212 : 0x001d 0x5103e116 : 	qbeq	cmd_write, r1, PRU_WRITE
  213 : 0x001e 0x5104e11f : 	qbeq	cmd_clear, r1, PRU_CLEAR
  214 : 0x001f 0x5105e151 : 	qbeq	cmd_bus_clk_stop, r1, PRU_BUS_CLK_STOP
  215 : 0x0020 0x5106e153 : 	qbeq	cmd_bus_clk_start, r1, PRU_BUS_CLK_START
  216 : 0x0021 0x5107e155 : 	qbeq	cmd_TI_meas, r1, PRU_TI_MEAS
  217 :                   : 
  218 :                   : 	// note that cmd_count() is run concurrently with command processing
  219 : 0x0022 0xf1042681 : 	eget	r1, r.m, m.count
  220 : 0x0023 0x5101e123 : 	qbeq	cmd_count, r1, PRU_COUNT
  221 : 0x0024 0x21001a00 : 	jmp		cmd_get
  222 :                   : 
  223 :                   : 
  224 :                   : // establish we're running by answering a ping
  225 :                   : cmd_ping:
  226 : 0x0025 0xf10c2681 : 	eget	r1, r.m, m.p0
  227 : 0x0026 0xf1102682 : 	eget	r2, r.m, m.p1
  228 : 0x0027 0x00e2e1e1 : 	add		r1, r1, r2
  229 : 0x0028 0xe1142681 :     eput	r1, r.m, m.p2
  230 : 0x0029 0xf1002781 :     eget	r1, r.m2, m2.m2_offset
  231 : 0x002a 0xe1182681 :     eput	r1, r.m, m.p3
  232 : 0x002b 0x21001800 : 	jmp 	cmd_done
  233 :                   : 
  234 :                   : 
  235 :                   : // 5370 bus read
  236 :                   : cmd_read:
  237 : 0x002c 0x240028f3 : 	mov		r.p0, OFFSET(m.a_gen_0)
  238 : 0x002d 0x23012adc : 	jsr2	set_addr
  239 : 0x002e 0x2300d59c : 	jsr1	bus_read
  240 : 0x002f 0xe1042793 : 	eput	r.p0, r.m2, m2.d_gen_0
  241 : 0x0030 0xe10c2794 : 	eput	r.p1, r.m2, m2.d_gen_1
  242 : 0x0031 0xe1142795 : 	eput	r.p2, r.m2, m2.d_gen_2
  243 : 0x0032 0x21001800 : 	jmp		cmd_done
  244 :                   : 
  245 :                   : 
  246 :                   : // 5370 bus write
  247 :                   : cmd_write:
  248 : 0x0033 0x240028f3 : 	mov		r.p0, OFFSET(m.a_gen_0)
  249 : 0x0034 0x23012adc : 	jsr2	set_addr
  250 : 0x0035 0xf1042793 : 	eget	r.p0, r.m2, m2.d_gen_0
  251 : 0x0036 0xf1082794 : 	eget	r.p1, r.m2, m2.d_gen_0c
  252 : 0x0037 0xf10c2795 : 	eget	r.p2, r.m2, m2.d_gen_1
  253 : 0x0038 0xf1102796 : 	eget	r.p3, r.m2, m2.d_gen_1c
  254 : 0x0039 0xf1142797 : 	eget	r.p4, r.m2, m2.d_gen_2
  255 : 0x003a 0xf1182798 : 	eget	r.p5, r.m2, m2.d_gen_2c
  256 : 0x003b 0x2300f19c : 	jsr1	bus_write
  257 : 0x003c 0x21001800 : 	jmp		cmd_done
  258 :                   : 
  259 :                   : 
  260 :                   : // clear overflow couters
  261 :                   : cmd_clear:
  262 : 0x003d 0x240000f9 : 	mov		r.n0_ovfl, 0
  263 : 0x003e 0xe11c2699 : 	eput	r.n0_ovfl, r.m, m.n0_ovfl
  264 : 0x003f 0x240000fa : 	mov		r.n3_ovfl, 0
  265 : 0x0040 0xe120269a : 	eput	r.n3_ovfl, r.m, m.n3_ovfl
  266 : 0x0041 0x240000fb : 	mov		r.ovfl_none, 0
  267 : 0x0042 0xe124269b : 	eput	r.ovfl_none, r.m, m.ovfl_none
  268 : 0x0043 0x240000e1 : 	mov		r1, PRU_DONE
  269 : 0x0044 0xe1042681 : 	eput	r1, r.m, m.count
  270 : 0x0045 0x21001800 : 	jmp 	cmd_done
  271 :                   : 
  272 :                   : 
  273 :                   : // count N0/N3 counter overflows; stop when EOM (end-of-measurement) detected
  274 :                   : cmd_count:
  275 : 0x0046 0xf1082681 : 	eget	r1, r.m, m.watchdog
  276 : 0x0047 0x0101e1e1 : 	add		r1, r1, 1
  277 : 0x0048 0xe1082681 : 	eput	r1, r.m, m.watchdog
  278 :                   : 
  279 : 0x0049 0x23015a9c : 	jsr1	wait_bus_clk					// let bus clock run
  280 : 0x004a 0x23013d9c : 	jsr1	addr_n0st
  281 : 0x004b 0x2300d59c : 	jsr1	bus_read
  282 :                   : 
  283 :                   : check_n0:
  284 : 0x004c 0x248000e1 : 	mov		r1, N0ST_N0_OVFL_GPIO			// on gpio1, active high
  285 : 0x004d 0x10e1f4e1 : 	and		r1, r.p1, r1
  286 : 0x004e 0x5100e10c : 	qbeq	check_n3, r1, 0
  287 : 0x004f 0x0101f9f9 : 	add		r.n0_ovfl, r.n0_ovfl, 1
  288 : 0x0050 0xe11c2699 : 	eput	r.n0_ovfl, r.m, m.n0_ovfl
  289 :                   : 
  290 : 0x0051 0x2301409c : 	jsr1	addr_out3
  291 : 0x0052 0xf1a02693 : 	eget	r.p0, r.m, m.d_n0_clr_ovfl_0
  292 : 0x0053 0xf1a42694 : 	eget	r.p1, r.m, m.d_n0_clr_ovfl_0c
  293 : 0x0054 0xf1a82695 : 	eget	r.p2, r.m, m.d_n0_clr_ovfl_1
  294 : 0x0055 0xf1ac2696 : 	eget	r.p3, r.m, m.d_n0_clr_ovfl_1c
  295 : 0x0056 0xf1b02697 : 	eget	r.p4, r.m, m.d_n0_clr_ovfl_2
  296 : 0x0057 0xf1b42698 : 	eget	r.p5, r.m, m.d_n0_clr_ovfl_2c
  297 : 0x0058 0x2300f19c : 	jsr1	bus_write
  298 : 0x0059 0x21001a00 : 	jmp		cmd_get
  299 :                   : 
  300 :                   : check_n3:
  301 : 0x005a 0x240010e1 : 	mov		r1, N0ST_N3_OVFL_GPIO			// on gpio2, active high
  302 : 0x005b 0x10e1f5e1 : 	and		r1, r.p2, r1
  303 : 0x005c 0x5100e10c : 	qbeq	check_eom, r1, 0
  304 : 0x005d 0x0101fafa : 	add		r.n3_ovfl, r.n3_ovfl, 1
  305 : 0x005e 0xe120269a : 	eput	r.n3_ovfl, r.m, m.n3_ovfl
  306 :                   : 
  307 : 0x005f 0x2301409c : 	jsr1	addr_out3
  308 : 0x0060 0xf1b82693 : 	eget	r.p0, r.m, m.d_n3_clr_ovfl_0
  309 : 0x0061 0xf1bc2694 : 	eget	r.p1, r.m, m.d_n3_clr_ovfl_0c
  310 : 0x0062 0xf1c02695 : 	eget	r.p2, r.m, m.d_n3_clr_ovfl_1
  311 : 0x0063 0xf1c42696 : 	eget	r.p3, r.m, m.d_n3_clr_ovfl_1c
  312 : 0x0064 0xf1c82697 : 	eget	r.p4, r.m, m.d_n3_clr_ovfl_2
  313 : 0x0065 0xf1cc2698 : 	eget	r.p5, r.m, m.d_n3_clr_ovfl_2c
  314 : 0x0066 0x2300f19c : 	jsr1	bus_write
  315 : 0x0067 0x21001a00 : 	jmp		cmd_get
  316 :                   : 
  317 :                   : check_eom:
  318 : 0x0068 0x0101fbfb : 	add		r.ovfl_none, r.ovfl_none, 1
  319 : 0x0069 0xe124269b : 	eput	r.ovfl_none, r.m, m.ovfl_none
  320 : 0x006a 0x242000e1 : 	mov		r1, N0ST_EOM_GPIO				// on gpio1, active low
  321 : 0x006b 0x10e1f4e1 : 	and		r1, r.p1, r1
  322 : 0x006c 0x6f00e1ae : 	qbne	cmd_get, r1, 0
  323 : 0x006d 0x240000e1 : 	mov		r1, PRU_DONE
  324 : 0x006e 0xe1042681 :     eput	r1, r.m, m.count
  325 : 0x006f 0x21001a00 : 	jmp		cmd_get
  326 :                   : 
  327 :                   : 
  328 :                   : cmd_bus_clk_stop:
  329 :                   : 	// BUS_CLK_STOP()
  330 : 0x0070 0x23015edc : 	jsr2	bus_clock_stop_deassert
  331 : 0x0071 0x230152dc : 	jsr2	wait_clk
  332 : 0x0072 0x21001800 : 	jmp		cmd_done
  333 :                   : 
  334 :                   : 
  335 :                   : cmd_bus_clk_start:
  336 :                   : 	// BUS_CLK_START()
  337 : 0x0073 0x230152dc : 	jsr2	wait_clk
  338 : 0x0074 0x230164dc : 	jsr2	bus_clock_start
  339 : 0x0075 0x21001800 : 	jmp		cmd_done
  340 :                   : 
  341 :                   : 
  342 :                   : // perform a fast TI measurement
  343 :                   : cmd_TI_meas:
  344 :                   : 
  345 :                   : 	// FAST_WRITE_ENTER()
  346 : 0x0076 0x2300ff9d : 	jsr3	fast_write_enter
  347 :                   : 
  348 :                   : 	// FAST_WRITE_GPIO_QUAL_CYCLE(ad_rst, 1,1,1,1,1,1,1,1)
  349 : 0x0077 0xf11c2781 : 	sgpio	r1, gpio0, ad_rst_0, ad_rst_0c
      : 0x0078 0xe0ef2881 : 
      : 0x0079 0xf1202781 : 
      : 0x007a 0xe0ee2881 : 
  350 : 0x007b 0xf1242781 : 	sgpio	r1, gpio1, ad_rst_1, ad_rst_1c
      : 0x007c 0xe0ef2981 : 
      : 0x007d 0xf1282781 : 
      : 0x007e 0xe0ee2981 : 
  351 : 0x007f 0xf12c2781 : 	sgpio	r1, gpio2, ad_rst_2, ad_rst_2c
      : 0x0080 0xe0ef2a81 : 
      : 0x0081 0xf1302781 : 
      : 0x0082 0xe0ee2a81 : 
  352 : 0x0083 0xf1342781 : 	sgpio	r1, gpio3, ad_rst_3, ad_rst_3c
      : 0x0084 0xe0ef2b81 : 
      : 0x0085 0xf1382781 : 
      : 0x0086 0xe0ee2b81 : 
  353 : 0x0087 0x23016a9d : 	jsr3	bus_clock_pulse
  354 :                   : 
  355 :                   : 	// FAST_WRITE_GPIO_QUAL_CYCLE(ad_ena, 1,1,1,1,1,1,1,1)
  356 : 0x0088 0xf13c2781 : 	sgpio	r1, gpio0, ad_ena_0, ad_ena_0c
      : 0x0089 0xe0ef2881 : 
      : 0x008a 0xf1402781 : 
      : 0x008b 0xe0ee2881 : 
  357 : 0x008c 0xf1442781 : 	sgpio	r1, gpio1, ad_ena_1, ad_ena_1c
      : 0x008d 0xe0ef2981 : 
      : 0x008e 0xf1482781 : 
      : 0x008f 0xe0ee2981 : 
  358 : 0x0090 0xf14c2781 : 	sgpio	r1, gpio2, ad_ena_2, ad_ena_2c
      : 0x0091 0xe0ef2a81 : 
      : 0x0092 0xf1502781 : 
      : 0x0093 0xe0ee2a81 : 
  359 : 0x0094 0xf1542781 : 	sgpio	r1, gpio3, ad_ena_3, ad_ena_3c
      : 0x0095 0xe0ef2b81 : 
      : 0x0096 0xf1582781 : 
      : 0x0097 0xe0ee2b81 : 
  360 : 0x0098 0x23016a9d : 	jsr3	bus_clock_pulse
  361 :                   : 
  362 :                   : 	// i.e. only gpio1 changes, gpio[023] same as previous write
  363 :                   : 	// FAST_WRITE_GPIO_QUAL_CYCLE(ad_arm, 0,0,1,1,0,0,0,0)
  364 : 0x0099 0xf1642781 : 	sgpio	r1, gpio1, ad_arm_1, ad_arm_1c
      : 0x009a 0xe0ef2981 : 
      : 0x009b 0xf1682781 : 
      : 0x009c 0xe0ee2981 : 
  365 : 0x009d 0x23016a9d : 	jsr3	bus_clock_pulse
  366 :                   : 
  367 :                   : 	// FAST_WRITE_EXIT()
  368 : 0x009e 0x2301149d : 	jsr3	fast_write_exit
  369 :                   : 
  370 :                   : 	// do {
  371 :                   : 	//     FAST_READ_GPIO1_CYCLE(1, n0st, a_n0st)
  372 :                   : 	// } while (n0st & N0ST_EOM_GPIO)
  373 : 0x009f 0x23013d9c : 	jsr1	addr_n0st
  374 :                   : 
  375 :                   : wait_eom:
  376 : 0x00a0 0x2300db9d : 	jsr3	bus_read1
  377 : 0x00a1 0x242000e1 : 	mov		r1, N0ST_EOM_GPIO				// on gpio1, active low
  378 : 0x00a2 0x10e1f4e1 : 	and		r1, r.p1, r1
  379 : 0x00a3 0x6f00e1fd : 	qbne	wait_eom, r1, 0
  380 :                   : 	
  381 :                   : 	// FAST_WRITE_ENTER()
  382 : 0x00a4 0x2300ff9d : 	jsr3	fast_write_enter
  383 :                   : 
  384 :                   : 	// FAST_WRITE_GPIO_CYCLE(ad_idle)
  385 : 0x00a5 0xf17c2781 : 	sgpio	r1, gpio0, ad_idle_0, ad_idle_0c
      : 0x00a6 0xe0ef2881 : 
      : 0x00a7 0xf1802781 : 
      : 0x00a8 0xe0ee2881 : 
  386 : 0x00a9 0xf1842781 : 	sgpio	r1, gpio1, ad_idle_1, ad_idle_1c
      : 0x00aa 0xe0ef2981 : 
      : 0x00ab 0xf1882781 : 
      : 0x00ac 0xe0ee2981 : 
  387 : 0x00ad 0xf18c2781 : 	sgpio	r1, gpio2, ad_idle_2, ad_idle_2c
      : 0x00ae 0xe0ef2a81 : 
      : 0x00af 0xf1902781 : 
      : 0x00b0 0xe0ee2a81 : 
  388 : 0x00b1 0xf1942781 : 	sgpio	r1, gpio3, ad_idle_3, ad_idle_3c
      : 0x00b2 0xe0ef2b81 : 
      : 0x00b3 0xf1982781 : 
      : 0x00b4 0xe0ee2b81 : 
  389 : 0x00b5 0x23016a9d : 	jsr3	bus_clock_pulse
  390 :                   : 
  391 :                   : 	// FAST_WRITE_EXIT()
  392 : 0x00b6 0x2301149d : 	jsr3	fast_write_exit
  393 :                   : 
  394 :                   : 	// FAST_READ_GPIO_CYCLE(a_n0st, n0st)
  395 : 0x00b7 0x23013d9c : 	jsr1	addr_n0st
  396 : 0x00b8 0x2300db9d : 	jsr3	bus_read1
  397 : 0x00b9 0xe19c2793 : 	eput	r.p0, r.m2, m2.d_n0st_0
  398 : 0x00ba 0xe1a02794 : 	eput	r.p1, r.m2, m2.d_n0st_1
  399 : 0x00bb 0xe1a42795 : 	eput	r.p2, r.m2, m2.d_n0st_2
  400 :                   : 
  401 :                   : 	// FAST_READ2_GPIO_CYCLE(a_n1n2h, n1n2_h, n1n2_l)
  402 : 0x00bc 0x240070f3 : 	mov		r.p0, OFFSET(m.a_n1n2_h_0)
  403 : 0x00bd 0x23012adc : 	jsr2	set_addr
  404 : 0x00be 0x2300db9d : 	jsr3	bus_read1
  405 : 0x00bf 0xe1a82793 : 	eput	r.p0, r.m2, m2.d_n1n2_h_0
  406 : 0x00c0 0xe1ac2794 : 	eput	r.p1, r.m2, m2.d_n1n2_h_1
  407 : 0x00c1 0xe1b02795 : 	eput	r.p2, r.m2, m2.d_n1n2_h_2
  408 : 0x00c2 0x240001c1 : 	mov		r1, BUS_LA0						// on gpio3, active low
      : 0x00c3 0x24000081 : 
  409 : 0x00c4 0xe0ef2b81 : 	st32	r1, r.gpio3, r.gpio_clr
  410 : 0x00c5 0xe1b42793 : 	eput	r.p0, r.m2, m2.d_n1n2_l_0
  411 : 0x00c6 0xe1b82794 : 	eput	r.p1, r.m2, m2.d_n1n2_l_1
  412 : 0x00c7 0xe1bc2795 : 	eput	r.p2, r.m2, m2.d_n1n2_l_2
  413 :                   : 
  414 :                   : 	// FAST_READ2_GPIO_CYCLE(a_n0h, n0_h, n0_l)
  415 : 0x00c8 0x240058f3 : 	mov		r.p0, OFFSET(m.a_n0_h_0)
  416 : 0x00c9 0x23012adc : 	jsr2	set_addr
  417 : 0x00ca 0x2300db9d : 	jsr3	bus_read1
  418 : 0x00cb 0xe1c02793 : 	eput	r.p0, r.m2, m2.d_n0_h_0
  419 : 0x00cc 0xe1c42794 : 	eput	r.p1, r.m2, m2.d_n0_h_1
  420 : 0x00cd 0xe1c82795 : 	eput	r.p2, r.m2, m2.d_n0_h_2
  421 : 0x00ce 0x240001c1 : 	mov		r1, BUS_LA0						// on gpio3, active low
      : 0x00cf 0x24000081 : 
  422 : 0x00d0 0xe0ef2b81 : 	st32	r1, r.gpio3, r.gpio_clr
  423 : 0x00d1 0xe1cc2793 : 	eput	r.p0, r.m2, m2.d_n0_l_0
  424 : 0x00d2 0xe1d02794 : 	eput	r.p1, r.m2, m2.d_n0_l_1
  425 : 0x00d3 0xe1d42795 : 	eput	r.p2, r.m2, m2.d_n0_l_2
  426 :                   : 
  427 : 0x00d4 0x21001800 : 	jmp		cmd_done
  428 :                   : 
  429 :                   : 
  430 :                   : // ---------------------------
  431 :                   : 
  432 :                   : // call with: address already set
  433 :                   : // returns: r.p0=gpio0 r.p1=gpio1 r.p2=gpio2
  434 :                   : bus_read:
  435 :                   : 	// BUS_CLK_STOP()
  436 : 0x00d5 0x23015edc : 	jsr2	bus_clock_stop_deassert
  437 : 0x00d6 0x230152dc : 	jsr2	wait_clk
  438 :                   : 	
  439 : 0x00d7 0x2300db9d : 	jsr3	bus_read1
  440 :                   : 
  441 :                   : 	// BUS_CLK_START()
  442 : 0x00d8 0x230152dc : 	jsr2	wait_clk
  443 : 0x00d9 0x230164dc : 	jsr2	bus_clock_start
  444 : 0x00da 0x209c0000 : 	rtn1
  445 :                   : 
  446 :                   : bus_read1:
  447 :                   : 	
  448 :                   : 	// FAST_READ_CYCLE()
  449 : 0x00db 0x240040c1 : 	mov		r1, BUS_DIR
      : 0x00dc 0x24000081 : 
  450 : 0x00dd 0xe0ee2881 : 	st32	r1, r.gpio0, r.gpio_set
  451 : 0x00de 0x240010e1 : 	mov		r1, BUS_LRW
  452 : 0x00df 0xe0ef2881 : 	st32	r1, r.gpio0, r.gpio_clr
  453 : 0x00e0 0x242000c1 : 	mov		r1, BUS_LVMA
      : 0x00e1 0x24000081 : 
  454 : 0x00e2 0xe0ef2981 : 	st32	r1, r.gpio1, r.gpio_clr
  455 : 0x00e3 0x230152dc : 	jsr2	wait_clk
  456 : 0x00e4 0x230161dc : 	jsr2	bus_clock_assert
  457 :                   : 	
  458 : 0x00e5 0x230156dc : 	jsr2	wait_access
  459 : 0x00e6 0xf0ec2893 : 	ld32	r.p0, r.gpio0, r.gpio_in
  460 : 0x00e7 0x1700f3f3 : 	not		r.p0, r.p0						// invert LDn
  461 : 0x00e8 0xf0ec2994 : 	ld32	r.p1, r.gpio1, r.gpio_in
  462 : 0x00e9 0x1700f4f4 : 	not		r.p1, r.p1
  463 : 0x00ea 0xf0ec2a95 : 	ld32	r.p2, r.gpio2, r.gpio_in
  464 : 0x00eb 0x1700f5f5 : 	not		r.p2, r.p2
  465 :                   : 	
  466 : 0x00ec 0x23015edc : 	jsr2	bus_clock_stop_deassert
  467 : 0x00ed 0x242000c1 : 	mov		r1, BUS_LVMA
      : 0x00ee 0x24000081 : 
  468 : 0x00ef 0xe0ee2981 : 	st32	r1, r.gpio1, r.gpio_set
  469 : 0x00f0 0x209d0000 : 	rtn3
  470 :                   : 
  471 :                   : 
  472 :                   : // call with:
  473 :                   : //		address already set
  474 :                   : //		r.p0=gpio0_set r.p1=gpio0_clr
  475 :                   : //		r.p2=gpio1_set r.p3=gpio1_clr
  476 :                   : //		r.p4=gpio2_set r.p5=gpio2_clr
  477 :                   : bus_write:
  478 :                   : 	// BUS_CLK_STOP()
  479 : 0x00f1 0x23015edc : 	jsr2	bus_clock_stop_deassert
  480 : 0x00f2 0x230152dc : 	jsr2	wait_clk
  481 :                   : 
  482 :                   : 	// FAST_WRITE_ENTER()
  483 : 0x00f3 0x2300ff9d : 	jsr3	fast_write_enter
  484 :                   : 
  485 :                   : 	// FAST_WRITE_CYCLE()
  486 : 0x00f4 0xe0ef2893 : 	st32	r.p0, r.gpio0, r.gpio_clr		// data is active low, so swap set/clr sense
  487 : 0x00f5 0xe0ee2894 : 	st32	r.p1, r.gpio0, r.gpio_set
  488 : 0x00f6 0xe0ef2995 : 	st32	r.p2, r.gpio1, r.gpio_clr
  489 : 0x00f7 0xe0ee2996 : 	st32	r.p3, r.gpio1, r.gpio_set
  490 : 0x00f8 0xe0ef2a97 : 	st32	r.p4, r.gpio2, r.gpio_clr
  491 : 0x00f9 0xe0ee2a98 : 	st32	r.p5, r.gpio2, r.gpio_set
  492 : 0x00fa 0x23016a9d : 	jsr3	bus_clock_pulse
  493 :                   : 
  494 :                   : 	// FAST_WRITE_EXIT()
  495 : 0x00fb 0x2301149d : 	jsr3	fast_write_exit
  496 :                   : 
  497 :                   : 	// BUS_CLK_START()
  498 : 0x00fc 0x230152dc : 	jsr2	wait_clk
  499 : 0x00fd 0x230164dc : 	jsr2	bus_clock_start
  500 : 0x00fe 0x209c0000 : 	rtn1
  501 :                   : 
  502 :                   : 
  503 :                   : fast_write_enter:
  504 :                   : 
  505 :                   : 	// FAST_WRITE_ENTER()
  506 : 0x00ff 0x240040c1 : 	mov		r1, BUS_DIR
      : 0x0100 0x24000081 : 
  507 : 0x0101 0xe0ef2881 : 	st32	r1, r.gpio0, r.gpio_clr
  508 :                   : 
  509 : 0x0102 0x24f37fc0 : 	mov		r0, (~G0_DATA)
      : 0x0103 0x24ffff80 : 
  510 : 0x0104 0x240000e1 : 	mov		r1, 0
  511 : 0x0105 0x230143dc : 	jsr2	set_oe0
  512 : 0x0106 0x24ffffc0 : 	mov		r0, (~G1_DATA)
      : 0x0107 0x240fff80 : 
  513 : 0x0108 0x240000e1 : 	mov		r1, 0
  514 : 0x0109 0x230148dc : 	jsr2	set_oe1
  515 : 0x010a 0x24ffffc0 : 	mov		r0, (~G2_DATA)
      : 0x010b 0x24ffef80 : 
  516 : 0x010c 0x240000e1 : 	mov		r1, 0
  517 : 0x010d 0x23014ddc : 	jsr2	set_oe2
  518 :                   : 
  519 : 0x010e 0x240010e1 : 	mov		r1, BUS_LRW
  520 : 0x010f 0xe0ee2881 : 	st32	r1, r.gpio0, r.gpio_set
  521 : 0x0110 0x242000c1 : 	mov		r1, BUS_LVMA
      : 0x0111 0x24000081 : 
  522 : 0x0112 0xe0ef2981 : 	st32	r1, r.gpio1, r.gpio_clr
  523 : 0x0113 0x209d0000 : 	rtn3
  524 :                   : 
  525 :                   : 
  526 :                   : fast_write_exit:
  527 :                   : 
  528 :                   : 	// FAST_WRITE_EXIT()
  529 : 0x0114 0x240010e1 : 	mov		r1, BUS_LRW
  530 : 0x0115 0xe0ef2881 : 	st32	r1, r.gpio0, r.gpio_clr
  531 : 0x0116 0x242000c1 : 	mov		r1, BUS_LVMA
      : 0x0117 0x24000081 : 
  532 : 0x0118 0xe0ee2981 : 	st32	r1, r.gpio1, r.gpio_set
  533 :                   : 
  534 : 0x0119 0x24ffffc0 : 	mov		r0, 0xffffffff
      : 0x011a 0x24ffff80 : 
  535 : 0x011b 0x240c80c1 : 	mov		r1, G0_DATA
      : 0x011c 0x24000081 : 
  536 : 0x011d 0x230143dc : 	jsr2	set_oe0
  537 : 0x011e 0x24ffffc0 : 	mov		r0, 0xffffffff
      : 0x011f 0x24ffff80 : 
  538 : 0x0120 0x24f000e1 : 	mov		r1, G1_DATA
  539 : 0x0121 0x230148dc : 	jsr2	set_oe1
  540 : 0x0122 0x24ffffc0 : 	mov		r0, 0xffffffff
      : 0x0123 0x24ffff80 : 
  541 : 0x0124 0x240010e1 : 	mov		r1, G2_DATA
  542 : 0x0125 0x23014ddc : 	jsr2	set_oe2
  543 :                   : 
  544 : 0x0126 0x240040c1 : 	mov		r1, BUS_DIR
      : 0x0127 0x24000081 : 
  545 : 0x0128 0xe0ee2881 : 	st32	r1, r.gpio0, r.gpio_set
  546 : 0x0129 0x209d0000 : 	rtn3
  547 :                   : 
  548 :                   : 
  549 :                   : // r.p0 = OFFSET(in r.m of address values)
  550 :                   : set_addr:
  551 : 0x012a 0xf0f32681 : 	ld32	r1, r.m, r.p0
  552 : 0x012b 0x0104f3f3 : 	add		r.p0, r.p0, 4
  553 : 0x012c 0xe0ef2881 : 	st32	r1, r.gpio0, r.gpio_clr			// set/clr order reversed for LAn
  554 :                   : 
  555 : 0x012d 0xf0f32681 : 	ld32	r1, r.m, r.p0
  556 : 0x012e 0x0104f3f3 : 	add		r.p0, r.p0, 4
  557 : 0x012f 0xe0ee2881 : 	st32	r1, r.gpio0, r.gpio_set
  558 :                   : 
  559 : 0x0130 0xf0f32681 : 	ld32	r1, r.m, r.p0
  560 : 0x0131 0x0104f3f3 : 	add		r.p0, r.p0, 4
  561 : 0x0132 0xe0ef2981 : 	st32	r1, r.gpio1, r.gpio_clr
  562 :                   : 
  563 : 0x0133 0xf0f32681 : 	ld32	r1, r.m, r.p0
  564 : 0x0134 0x0104f3f3 : 	add		r.p0, r.p0, 4
  565 : 0x0135 0xe0ee2981 : 	st32	r1, r.gpio1, r.gpio_set
  566 :                   : 
  567 : 0x0136 0xf0f32681 : 	ld32	r1, r.m, r.p0
  568 : 0x0137 0x0104f3f3 : 	add		r.p0, r.p0, 4
  569 : 0x0138 0xe0ef2b81 : 	st32	r1, r.gpio3, r.gpio_clr
  570 :                   : 
  571 : 0x0139 0xf0f32681 : 	ld32	r1, r.m, r.p0
  572 : 0x013a 0x0104f3f3 : 	add		r.p0, r.p0, 4
  573 : 0x013b 0xe0ee2b81 : 	st32	r1, r.gpio3, r.gpio_set
  574 : 0x013c 0x20dc0000 : 	rtn2
  575 :                   : 
  576 :                   : addr_n0st:
  577 : 0x013d 0x240040f3 : 	mov		r.p0, OFFSET(m.a_n0st_0)
  578 : 0x013e 0x23012adc : 	jsr2	set_addr
  579 : 0x013f 0x209c0000 : 	rtn1
  580 :                   : 
  581 :                   : addr_out3:
  582 : 0x0140 0x240088f3 : 	mov		r.p0, OFFSET(m.a_o3_0)
  583 : 0x0141 0x23012adc : 	jsr2	set_addr
  584 : 0x0142 0x209c0000 : 	rtn1
  585 :                   : 
  586 :                   : set_oe0:
  587 : 0x0143 0xf0ed2883 : 	ld32	r3, r.gpio0, r.gpio_oe
  588 : 0x0144 0x10e0e3e3 : 	and		r3, r3, r0
  589 : 0x0145 0x12e1e3e3 : 	or		r3, r3, r1
  590 : 0x0146 0xe0ed2883 : 	st32	r3, r.gpio0, r.gpio_oe
  591 : 0x0147 0x20dc0000 : 	rtn2
  592 :                   : 
  593 :                   : set_oe1:
  594 : 0x0148 0xf0ed2983 : 	ld32	r3, r.gpio1, r.gpio_oe
  595 : 0x0149 0x10e0e3e3 : 	and		r3, r3, r0
  596 : 0x014a 0x12e1e3e3 : 	or		r3, r3, r1
  597 : 0x014b 0xe0ed2983 : 	st32	r3, r.gpio1, r.gpio_oe
  598 : 0x014c 0x20dc0000 : 	rtn2
  599 :                   : 
  600 :                   : set_oe2:
  601 : 0x014d 0xf0ed2a83 : 	ld32	r3, r.gpio2, r.gpio_oe
  602 : 0x014e 0x10e0e3e3 : 	and		r3, r3, r0
  603 : 0x014f 0x12e1e3e3 : 	or		r3, r3, r1
  604 : 0x0150 0xe0ed2a83 : 	st32	r3, r.gpio2, r.gpio_oe
  605 : 0x0151 0x20dc0000 : 	rtn2
  606 :                   : 	
  607 :                   : wait_clk:
  608 :                   : 	// 100 ns
  609 : 0x0152 0x24000ae1 : 	mov		r1, 10
  610 :                   : wait_clk1:
  611 : 0x0153 0x0501e1e1 : 	sub		r1, r1, 1
  612 : 0x0154 0x6f00e1ff : 	qbne	wait_clk1, r1, 0
  613 : 0x0155 0x20dc0000 : 	rtn2
  614 :                   : 	
  615 :                   : wait_access:
  616 :                   : 	// 800 ns
  617 : 0x0156 0x240050e1 : 	mov		r1, 80
  618 :                   : wait_access1:
  619 : 0x0157 0x0501e1e1 : 	sub		r1, r1, 1
  620 : 0x0158 0x6f00e1ff : 	qbne	wait_access1, r1, 0
  621 : 0x0159 0x20dc0000 : 	rtn2
  622 :                   : 
  623 :                   : wait_bus_clk:
  624 :                   : 	// 50 us
  625 : 0x015a 0x241388e1 : 	mov		r1, 5000
  626 :                   : wait_bus_clk1:
  627 : 0x015b 0x0501e1e1 : 	sub		r1, r1, 1
  628 : 0x015c 0x6f00e1ff : 	qbne	wait_bus_clk1, r1, 0
  629 : 0x015d 0x20dc0000 : 	rtn2
  630 :                   : 	
  631 :                   : bus_clock_stop_deassert:
  632 : 0x015e 0x241402e1 : 	mov		r1, T_MODE
  633 : 0x015f 0xe0f13081 : 	st32	r1,	r.timer, r.timer_tclr
  634 : 0x0160 0x20dc0000 : 	rtn2
  635 :                   : 	
  636 :                   : bus_clock_assert:
  637 : 0x0161 0x241482e1 : 	mov		r1, (T_MODE | T_HIGH)
  638 : 0x0162 0xe0f13081 : 	st32	r1,	r.timer, r.timer_tclr
  639 : 0x0163 0x20dc0000 : 	rtn2
  640 :                   : 	
  641 :                   : bus_clock_start:
  642 : 0x0164 0x24ffffc1 : 	mov		r1, -9
      : 0x0165 0x24fff781 : 
  643 : 0x0166 0xe0f23081 : 	st32	r1,	r.timer, r.timer_tcrr
  644 : 0x0167 0x241403e1 : 	mov		r1, (T_MODE | T_START)
  645 : 0x0168 0xe0f13081 : 	st32	r1,	r.timer, r.timer_tclr
  646 : 0x0169 0x20dc0000 : 	rtn2
  647 :                   : 
  648 :                   : bus_clock_pulse:
  649 : 0x016a 0x230156dc : 	jsr2	wait_access
  650 : 0x016b 0x230161dc : 	jsr2	bus_clock_assert
  651 : 0x016c 0x230156dc : 	jsr2	wait_access
  652 : 0x016d 0x23015edc : 	jsr2	bus_clock_stop_deassert
  653 : 0x016e 0x230152dc : 	jsr2	wait_clk
  654 : 0x016f 0x209d0000 : 	rtn3
  655 :                   : 

Source File 2 : 'pru_realtime.hp' (No Ouput Generated)

    1 :                   : // *
    2 :                   : // * PRU_memAccessPRUDataRam.hp
    3 :                   : // *
    4 :                   : // * Copyright (C) 2012 Texas Instruments Incorporated - http://www.ti.com/
    5 :                   : // *
    6 :                   : // *
    7 :                   : // *  Redistribution and use in source and binary forms, with or without
    8 :                   : // *  modification, are permitted provided that the following conditions
    9 :                   : // *  are met:
   10 :                   : // *
   11 :                   : // *    Redistributions of source code must retain the above copyright
   12 :                   : // *    notice, this list of conditions and the following disclaimer.
   13 :                   : // *
   14 :                   : // *    Redistributions in binary form must reproduce the above copyright
   15 :                   : // *    notice, this list of conditions and the following disclaimer in the
   16 :                   : // *    documentation and/or other materials provided with the
   17 :                   : // *    distribution.
   18 :                   : // *
   19 :                   : // *    Neither the name of Texas Instruments Incorporated nor the names of
   20 :                   : // *    its contributors may be used to endorse or promote products derived
   21 :                   : // *    from this software without specific prior written permission.
   22 :                   : // *
   23 :                   : // *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   24 :                   : // *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   25 :                   : // *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   26 :                   : // *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   27 :                   : // *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   28 :                   : // *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   29 :                   : // *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   30 :                   : // *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   31 :                   : // *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   32 :                   : // *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   33 :                   : // *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   34 :                   : // *
   35 :                   : // *
   36 :                   : 
   37 :                   : // *
   38 :                   : // * ============================================================================
   39 :                   : // * Copyright (c) Texas Instruments Inc 2010-12
   40 :                   : // *
   41 :                   : // * Use of this software is controlled by the terms and conditions found in the
   42 :                   : // * license agreement under which this software has been supplied or provided.
   43 :                   : // * ============================================================================
   44 :                   : // *
   45 :                   : 
   46 :                   : #ifndef _PRU_REALTIME_HP_
   47 :                   : #define _PRU_REALTIME_HP_
   48 :                   : 
   49 :                   : #include "pru_realtime.h"
   50 :                   : 
   51 :                   : // Refer to this mapping in the file - \prussdrv\include\pruss_intc_mapping.h
   52 :                   : #define PRU0_PRU1_INTERRUPT     17
   53 :                   : #define PRU1_PRU0_INTERRUPT     18
   54 :                   : #define PRU0_ARM_INTERRUPT      19
   55 :                   : #define PRU1_ARM_INTERRUPT      20
   56 :                   : #define ARM_PRU0_INTERRUPT      21
   57 :                   : #define ARM_PRU1_INTERRUPT      22
   58 :                   : 
   59 :                   : #define CONST_PRUDRAM   C24
   60 :                   : #define CONST_L3RAM     C30
   61 :                   : #define CONST_DDR       C31
   62 :                   : 
   63 :                   : // Address for the Constant table Block Index Register 0(CTBIR_0)
   64 :                   : #define CTBIR_0         0x22020
   65 :                   : // Address for the Constant table Block Index Register 0(CTBIR_1)
   66 :                   : #define CTBIR_1         0x22024
   67 :                   : 
   68 :                   : // Address for the Constant table Programmable Pointer Register 0(CTPPR_0)
   69 :                   : #define CTPPR_0         0x22028
   70 :                   : // Address for the Constant table Programmable Pointer Register 1(CTPPR_1)
   71 :                   : #define CTPPR_1         0x2202C
   72 :                   : 
   73 :                   : 
   74 :                   : // setting gpio registers
   75 :                   : .macro sgpio
   76 :                   : .mparam treg, gpio, adval, advalc
   77 :                   : 	eget	treg, r.m2, m2.adval
   78 :                   : 	st32	treg, r.gpio, r.gpio_clr
   79 :                   : 	eget	treg, r.m2, m2.advalc
   80 :                   : 	st32	treg, r.gpio, r.gpio_set
   81 :                   : .endm
   82 :                   : 
   83 :                   : 
   84 :                   : // call/return from nested levels (use different return address regs)
   85 :                   : 
   86 :                   : .macro jsr1
   87 :                   : .mparam	dst
   88 :                   : 	jal		r.ra1.w0, dst
   89 :                   : .endm
   90 :                   : 
   91 :                   : .macro rtn1
   92 :                   : 	jmp		r.ra1.w0
   93 :                   : .endm
   94 :                   : 
   95 :                   : .macro jsr2
   96 :                   : .mparam	dst
   97 :                   : 	jal		r.ra2.w0, dst
   98 :                   : .endm
   99 :                   : 
  100 :                   : .macro rtn2
  101 :                   : 	jmp		r.ra2.w0
  102 :                   : .endm
  103 :                   : 
  104 :                   : .macro jsr3
  105 :                   : .mparam	dst
  106 :                   : 	jal		r.ra3.w0, dst
  107 :                   : .endm
  108 :                   : 
  109 :                   : .macro rtn3
  110 :                   : 	jmp		r.ra3.w0
  111 :                   : .endm
  112 :                   : 
  113 :                   : 
  114 :                   : // get/put elements from a .struct
  115 :                   : 
  116 :                   : .macro eget
  117 :                   : .mparam dst, src, elem
  118 :                   :     lbbo    dst, src, OFFSET(elem), SIZE(elem)
  119 :                   : .endm
  120 :                   : 
  121 :                   : .macro eput
  122 :                   : .mparam src, dst, elem
  123 :                   :     sbbo    src, dst, OFFSET(elem), SIZE(elem)
  124 :                   : .endm
  125 :                   : 
  126 :                   : 
  127 :                   : // load/store shorthand
  128 :                   : 
  129 :                   : .macro  ld32
  130 :                   : .mparam dst, src, off
  131 :                   :     lbbo    dst, src, off, 4
  132 :                   : .endm
  133 :                   : 
  134 :                   : .macro  ld16
  135 :                   : .mparam dst, src, off
  136 :                   :     lbbo    dst, src, off, 2
  137 :                   : .endm
  138 :                   : 
  139 :                   : .macro  ld8
  140 :                   : .mparam dst, src, off
  141 :                   :     lbbo    dst, src, off, 1
  142 :                   : .endm
  143 :                   : 
  144 :                   : .macro st32
  145 :                   : .mparam src, dst, off
  146 :                   :     sbbo    src, dst, off, 4
  147 :                   : .endm
  148 :                   : 
  149 :                   : .macro st16
  150 :                   : .mparam src, dst, off
  151 :                   :     sbbo    src, dst, off, 2
  152 :                   : .endm
  153 :                   : 
  154 :                   : .macro st8
  155 :                   : .mparam src, dst, off
  156 :                   :     sbbo    src, dst, off, 1
  157 :                   : .endm
  158 :                   : 
  159 :                   : #endif //_PRU_REALTIME_HP_
  160 :                   : 

Source File 3 : 'pru_realtime.h' (No Ouput Generated)

    1 :                   : #ifndef _PRU_REALTIME_H_
    2 :                   : #define _PRU_REALTIME_H_
    3 :                   : 
    4 :                   : #define	PRU_DONE			0
    5 :                   : #define	PRU_PING			1
    6 :                   : #define	PRU_READ			2
    7 :                   : #define	PRU_WRITE			3
    8 :                   : #define	PRU_CLEAR			4
    9 :                   : #define PRU_BUS_CLK_STOP	5
   10 :                   : #define PRU_BUS_CLK_START	6
   11 :                   : #define	PRU_TI_MEAS			7
   12 :                   : 
   13 :                   : #define	PRU_COUNT		1
   14 :                   : 
   15 :                   : 
   16 :                   : // no -I path when using pasm
   17 :                   : #include "../arch/sitara/sitara.h"
   18 :                   : #include "../5370/5370_regs.h"
   19 :                   : 
   20 :                   : #define PRU_COM_SIZE	(64*4)		// 64 entries max in a PRU assembler .struct
   21 :                   : #define PRU_COM_MEM		0
   22 :                   : #define PRU_COM_MEM2	(PRU_COM_MEM + PRU_COM_SIZE)
   23 :                   : 
   24 :                   : #ifndef _PASM_
   25 :                   : 
   26 :                   : #include "misc.h"
   27 :                   : 
   28 :                   : // shared memory used to communicate with PRU
   29 :                   : // layout must match pru_realtime.p
   30 :                   : typedef volatile struct {
   31 :                   : 	u4_t cmd;
   32 :                   : 	u4_t count;
   33 :                   : 	u4_t watchdog;
   34 :                   : 	u4_t p[4];
   35 :                   : 
   36 :                   : 	u4_t n0_ovfl, n3_ovfl, ovfl_none;
   37 :                   : 
   38 :                   : 	CONV_ADDR_DCL(a_gen);
   39 :                   : 	
   40 :                   : 	CONV_ADDR_DCL(a_n0st);
   41 :                   : 	CONV_ADDR_DCL(a_n0_h);
   42 :                   : 	CONV_ADDR_DCL(a_n1n2_h);
   43 :                   : 	CONV_ADDR_DCL(a_o3);
   44 :                   : 	
   45 :                   : 	CONV_DATA_DCL(d_n0_clr_ovfl);
   46 :                   : 	CONV_DATA_DCL(d_n3_clr_ovfl);
   47 :                   : } com_t;
   48 :                   : 
   49 :                   : extern com_t *pru;
   50 :                   : 
   51 :                   : typedef volatile struct {
   52 :                   : 	u4_t m2_offset;
   53 :                   : 	
   54 :                   : 	CONV_DATA_DCL(d_gen);
   55 :                   : 	
   56 :                   : 	CONV_ADDR_DATA_DCL(ad_rst);
   57 :                   : 	CONV_ADDR_DATA_DCL(ad_ena);
   58 :                   : 	CONV_ADDR_DATA_DCL(ad_arm);
   59 :                   : 	CONV_ADDR_DATA_DCL(ad_idle);
   60 :                   : 
   61 :                   : 	CONV_DATA_READ_DCL(d_n0st);
   62 :                   : 	CONV_DATA_READ_DCL(d_n1n2_h);
   63 :                   : 	CONV_DATA_READ_DCL(d_n1n2_l);
   64 :                   : 	CONV_DATA_READ_DCL(d_n0_h);
   65 :                   : 	CONV_DATA_READ_DCL(d_n0_l);
   66 :                   : } com2_t;
   67 :                   : 
   68 :                   : extern com2_t *pru2;
   69 :                   : 
   70 :                   : void pru_start();
   71 :                   : 
   72 :                   : #endif
   73 :                   : 
   74 :                   : #endif
   75 :                   : 

Source File 4 : 'sitara.h' (No Ouput Generated)

    1 :                   : #ifndef _SITARA_H_
    2 :                   : #define _SITARA_H_
    3 :                   : 
    4 :                   : #include "bus.h"
    5 :                   : 
    6 :                   : #ifndef _PASM_
    7 :                   :  #include CHIP_INCLUDE
    8 :                   : #endif
    9 :                   : 
   10 :                   : // Sitara memory map
   11 :                   : #define PRCM_BASE	0x44e00000		// power, reset, clock management
   12 :                   : #define PMUX_BASE	0x44e10000		// control module for pin mux
   13 :                   : #define GPIO0_BASE	0x44e07000
   14 :                   : #define GPIO1_BASE	0x4804c000
   15 :                   : #define GPIO2_BASE	0x481ac000
   16 :                   : #define GPIO3_BASE	0x481ae000
   17 :                   : #define SPI0_BASE	0x48030000
   18 :                   : #define TIMER4_BASE	0x48044000
   19 :                   : #define GPMC_BASE	0x50000000		// general purpose memory controller (not used presently)
   20 :                   : 
   21 :                   : #define MMAP_SIZE	0x1000
   22 :                   : 
   23 :                   : 
   24 :                   : // PRCM: power, reset, clock management
   25 :                   : #define PRCM_GPIO1	prcm[0x0ac>>2]
   26 :                   : #define PRCM_GPIO2	prcm[0x0b0>>2]
   27 :                   : #define PRCM_GPIO3	prcm[0x0b4>>2]
   28 :                   : #define PRCM_SPI0	prcm[0x04c>>2]
   29 :                   : #define PRCM_TIMER4	prcm[0x088>>2]
   30 :                   : #define PRCM_TIMER5	prcm[0x0ec>>2]
   31 :                   : #define PRCM_TIMER6	prcm[0x0f0>>2]
   32 :                   : #define PRCM_TIMER7	prcm[0x07c>>2]
   33 :                   : #define PRCM_PMUX	prcm[0x404>>2]
   34 :                   : #define PRCM_GPIO0	prcm[0x408>>2]
   35 :                   : 
   36 :                   : #define MODMODE_ENA	0x2			// power-up module
   37 :                   : 
   38 :                   : 
   39 :                   : // PMUX: pin mux (remember: Linux doesn't allow write of pmux via mmap -- use device tree (dts) mechanism instead)
   40 :                   : #define	PMUX_SLOW	0x40		// slew rate
   41 :                   : #define	PMUX_FAST	0x00
   42 :                   : #define	PMUX_RXEN	0x20
   43 :                   : #define	PMUX_TXEN	0x00
   44 :                   : #define	PMUX_PU		0x10		// 1 = pull-up
   45 :                   : #define	PMUX_PD		0x00		// 0 = pull-down
   46 :                   : #define	PMUX_PDIS	0x08		// 1 = pull disable
   47 :                   : #define	PMUX_M7		0x07
   48 :                   : #define	PMUX_M2		0x02
   49 :                   : 
   50 :                   : #define	PMUX_OUTPUT	(PMUX_FAST | PMUX_TXEN | PMUX_PDIS)
   51 :                   : #define	PMUX_INPUT	(PMUX_FAST | PMUX_RXEN | PMUX_PU)
   52 :                   : #define	PMUX_INOUT	(PMUX_FAST | PMUX_TXEN | PMUX_RXEN | PMUX_PU)
   53 :                   : 
   54 :                   : 
   55 :                   : // GPIO
   56 :                   : #define	_GPIO_REVISION		0x000
   57 :                   : #define	_GPIO_SYSCONFIG		0x010
   58 :                   : #define	_GPIO_CLR_IRQ0		0x03c
   59 :                   : #define	_GPIO_CLR_IRQ1		0x040
   60 :                   : #define	_GPIO_OE			0x134
   61 :                   : #define	_GPIO_IN			0x138
   62 :                   : #define	_GPIO_OUT			0x13c
   63 :                   : #define	_GPIO_CLR			0x190
   64 :                   : #define	_GPIO_SET			0x194
   65 :                   : 
   66 :                   : 
   67 :                   : #ifndef _PASM_
   68 :                   : #define GPIO_REVISION(n)	gpio ## n[_GPIO_REVISION>>2]
   69 :                   : #define GPIO_SYSCONFIG(n)	gpio ## n[_GPIO_SYSCONFIG>>2]
   70 :                   : #define GPIO_CLR_IRQ0(n)	gpio ## n[_GPIO_CLR_IRQ0>>2]
   71 :                   : #define GPIO_CLR_IRQ1(n)	gpio ## n[_GPIO_CLR_IRQ1>>2]
   72 :                   : #define GPIO_OE(n)			gpio ## n[_GPIO_OE>>2]			// 0 = output
   73 :                   : #define GPIO_IN(n)			gpio ## n[_GPIO_IN>>2]
   74 :                   : #define GPIO_OUT(n)			gpio ## n[_GPIO_OUT>>2]
   75 :                   : #define GPIO_CLR(n)			gpio ## n[_GPIO_CLR>>2]
   76 :                   : #define GPIO_SET(n)			gpio ## n[_GPIO_SET>>2]
   77 :                   : 
   78 :                   : #define	GPIO_OUTPUT(n, bits)	GPIO_OE(n) = GPIO_OE(n) & ~(bits);
   79 :                   : #define	GPIO_INPUT(n, bits)		GPIO_OE(n) = GPIO_OE(n) | (bits);
   80 :                   : #endif
   81 :                   : 
   82 :                   : // TIMER
   83 :                   : #define	T_TOGGLE		(1<<12)
   84 :                   : #define	T_TRIG_OVFL		(1<<10)
   85 :                   : #define	T_HIGH			(1<<7)
   86 :                   : #define	T_RELOAD		(1<<1)
   87 :                   : #define	T_START			(1<<0)
   88 :                   : #define	T_MODE			(T_TOGGLE | T_TRIG_OVFL | T_RELOAD)
   89 :                   : 
   90 :                   : #define _TIMER_TCLR		0x38
   91 :                   : #define _TIMER_TCRR		0x3c
   92 :                   : #define _TIMER_TLDR		0x40
   93 :                   : 
   94 :                   : #ifndef _PASM_
   95 :                   : 
   96 :                   : #define TIMER_TCLR(n)	timer ## n[_TIMER_TCLR>>2]
   97 :                   : #define TIMER_TCRR(n)	timer ## n[_TIMER_TCRR>>2]
   98 :                   : #define TIMER_TLDR(n)	timer ## n[_TIMER_TLDR>>2]
   99 :                   : 
  100 :                   : 
  101 :                   : #define CHECK_IRQ() ((GPIO_IN(0) & BUS_LIRQ) == 0)
  102 :                   : #define CHECK_NMI() ((GPIO_IN(1) & BUS_LNMI) == 0)
  103 :                   : 
  104 :                   : #define TEST1_SET()
  105 :                   : #define TEST1_CLR()
  106 :                   : #define TEST2_SET()
  107 :                   : #define TEST2_CLR()
  108 :                   : #define TEST3_SET()
  109 :                   : #define TEST3_CLR()
  110 :                   : 
  111 :                   : // the 5370 bus clk is generated by a timer except during bus cycles when it's done manually.
  112 :                   : #define BUS_CLK_ASSERT() \
  113 :                   : 	TIMER_TCLR(4) = T_MODE | T_HIGH;
  114 :                   : 
  115 :                   : #define BUS_CLK_DEASSERT() \
  116 :                   : 	TIMER_TCLR(4) = T_MODE;
  117 :                   : 
  118 :                   : #define BUS_CLK_STOP() \
  119 :                   : 	TIMER_TCLR(4) = T_MODE;		/* lack of T_HIGH should leave BUS_CLK low */
  120 :                   : 
  121 :                   : #define BUS_CLK_START() \
  122 :                   : 	TIMER_TCRR(4) = -9; \
  123 :                   : 	TIMER_TCLR(4) = T_MODE | T_START;
  124 :                   : 
  125 :                   : 
  126 :                   : extern u4_t g0_addr[], g1_addr[], g3_addr[];
  127 :                   : extern u4_t g0_write[], g1_write[], g2_write[];
  128 :                   : 
  129 :                   : // remember: address bus is inverted (LAn) so sense of SET/CLR is reversed here
  130 :                   : #define SET_ADDR(a) \
  131 :                   : 	GPIO_CLR(0) = g0_addr[a]; \
  132 :                   : 	GPIO_SET(0) = ~g0_addr[a] & G0_ADDR; \
  133 :                   : 	GPIO_CLR(1) = g1_addr[a]; \
  134 :                   : 	GPIO_SET(1) = ~g1_addr[a] & G1_ADDR; \
  135 :                   : 	GPIO_CLR(3) = g3_addr[a]; \
  136 :                   : 	GPIO_SET(3) = ~g3_addr[a] & G3_ADDR;
  137 :                   : 
  138 :                   : #define FAST_READ_CYCLE(addr, data) \
  139 :                   :     SET_ADDR(addr); \
  140 :                   : 	\
  141 :                   : 	GPIO_SET(0) = BUS_DIR; \
  142 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  143 :                   : 	GPIO_CLR(1) = BUS_LVMA; \
  144 :                   : 	BUS_CLK_ASSERT(); \
  145 :                   : 	\
  146 :                   : 	t = GPIO_IN(0); /* extra delay before read of bus */ \
  147 :                   : 	t = GPIO_IN(0); \
  148 :                   : 	data = ((t & BUS_LD0) >> 27) | ((t & BUS_LD3) >> 23) | ((t & BUS_LD4) >> 19); \
  149 :                   : 	t = GPIO_IN(1); \
  150 :                   : 	data |= ((t & BUS_LD1) >> 13) | ((t & BUS_LD2) >> 13) | ((t & BUS_LD5) >> 7) | ((t & BUS_LD6) >> 7); \
  151 :                   : 	t = GPIO_IN(2); \
  152 :                   : 	data |= ((t & BUS_LD7) << 3); \
  153 :                   : 	data = ~data & 0xff; /* remember: have to invert LDn */ \
  154 :                   : 	\
  155 :                   : 	BUS_CLK_DEASSERT(); \
  156 :                   : 	GPIO_SET(1) = BUS_LVMA;
  157 :                   : 
  158 :                   : // remember: data bus is inverted (LDn) so sense of SET/CLR is reversed here
  159 :                   : #define FAST_WRITE_CYCLE(addr, d) \
  160 :                   :     SET_ADDR(addr); \
  161 :                   : 	GPIO_CLR(0) = g0_write[d]; \
  162 :                   : 	GPIO_SET(0) = ~g0_write[d] & G0_DATA; \
  163 :                   : 	GPIO_CLR(1)= g1_write[d]; \
  164 :                   : 	GPIO_SET(1) = ~g1_write[d] & G1_DATA; \
  165 :                   : 	GPIO_CLR(2) = g2_write[d]; \
  166 :                   : 	GPIO_SET(2) = ~g2_write[d] & G2_DATA; \
  167 :                   : 	\
  168 :                   : 	/* pulse the bus clock */ \
  169 :                   : 	BUS_CLK_ASSERT(); \
  170 :                   : 	GPIO_CLR(0) = g0_write[d]; /* extra delay while clk asserted */ \
  171 :                   : 	BUS_CLK_DEASSERT();
  172 :                   : 
  173 :                   : #ifdef DEBUG
  174 :                   : #define FAST_WRITE_ENTER() \
  175 :                   : 	GPIO_CLR(0) = BUS_DIR; /* write */ \
  176 :                   : 	GPIO_SET(0) = G0_DATA; /* don't glitch bus with old data (makes it easier to understand bus activity on logic analyzer) */ \
  177 :                   : 	GPIO_SET(1) = G1_DATA; \
  178 :                   : 	GPIO_SET(2) = G2_DATA; \
  179 :                   :     GPIO_OUTPUT(0, G0_DATA); /* drive data lines */ \
  180 :                   :     GPIO_OUTPUT(1, G1_DATA); \
  181 :                   :     GPIO_OUTPUT(2, G2_DATA); \
  182 :                   :     \
  183 :                   : 	GPIO_SET(0) = BUS_LRW; \
  184 :                   : 	GPIO_CLR(1) = BUS_LVMA;
  185 :                   : #else
  186 :                   : #define FAST_WRITE_ENTER() \
  187 :                   : 	GPIO_CLR(0) = BUS_DIR; /* write */ \
  188 :                   :     GPIO_OUTPUT(0, G0_DATA); /* drive data lines */ \
  189 :                   :     GPIO_OUTPUT(1, G1_DATA); \
  190 :                   :     GPIO_OUTPUT(2, G2_DATA); \
  191 :                   :     \
  192 :                   : 	GPIO_SET(0) = BUS_LRW; \
  193 :                   : 	GPIO_CLR(1) = BUS_LVMA;
  194 :                   : #endif
  195 :                   : 
  196 :                   : #define FAST_WRITE_EXIT() \
  197 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  198 :                   : 	GPIO_SET(1) = BUS_LVMA; \
  199 :                   : 	\
  200 :                   :     GPIO_INPUT(0, G0_DATA); \
  201 :                   :     GPIO_INPUT(1, G1_DATA); \
  202 :                   :     GPIO_INPUT(2, G2_DATA); \
  203 :                   : 	GPIO_SET(0) = BUS_DIR; /* read */
  204 :                   : 
  205 :                   : 
  206 :                   : // to support PRU and hpib_fast_binary()
  207 :                   : //
  208 :                   : // The v3 PCB was designed in a huge hurry and assignments of address, data and control signals to
  209 :                   : // gpio pins was done to facilitate the layout. As a result the consecutive bits of, say, the data bus
  210 :                   : // are scrambled out-of-order across multiple gpio registers. The software has to manage this situation
  211 :                   : // and there is a resulting performance penalty. The complex macros below are an attempt to increase
  212 :                   : // efficiency for fast binary transfer mode by exploiting known facts about the data transfer loop code.
  213 :                   : // The v4 PCB will definitely be redesigned to avoid this problem.
  214 :                   : 
  215 :                   : #define CONV_ADDR_DCL(avar) \
  216 :                   : 	u4_t _ ## avar ## 0, _ ## avar ## 0c, _ ## avar ## 1, _ ## avar ## 1c, _ ## avar ## 3, _ ## avar ## 3c;
  217 :                   : 
  218 :                   : // pre-compute address
  219 :                   : #define CONV_ADDR(prefix, avar, addr) \
  220 :                   : 	prefix ## avar ## 0 = g0_addr[addr]; \
  221 :                   : 	prefix ## avar ## 0c = ~g0_addr[addr] & G0_ADDR; \
  222 :                   : 	prefix ## avar ## 1 = g1_addr[addr]; \
  223 :                   : 	prefix ## avar ## 1c = ~g1_addr[addr] & G1_ADDR; \
  224 :                   : 	prefix ## avar ## 3 = g3_addr[addr]; \
  225 :                   : 	prefix ## avar ## 3c = ~g3_addr[addr] & G3_ADDR;
  226 :                   : 
  227 :                   : #define CONV_DATA_DCL(dvar) \
  228 :                   : 	u4_t _ ## dvar ## 0, _ ## dvar ## 0c, _ ## dvar ## 1, _ ## dvar ## 1c, _ ## dvar ## 2, _ ## dvar ## 2c;
  229 :                   : 
  230 :                   : #define CONV_DATA_READ_DCL(dvar) \
  231 :                   : 	u4_t _ ## dvar ## 0, _ ## dvar ## 1, _ ## dvar ## 2;
  232 :                   : 
  233 :                   : // pre-compute write data
  234 :                   : #define CONV_WRITE_DATA(prefix, dvar, data) \
  235 :                   : 	prefix ## dvar ## 0 = g0_write[data]; \
  236 :                   : 	prefix ## dvar ## 0c = ~g0_write[data] & G0_DATA; \
  237 :                   : 	prefix ## dvar ## 1 = g1_write[data]; \
  238 :                   : 	prefix ## dvar ## 1c = ~g1_write[data] & G1_DATA; \
  239 :                   : 	prefix ## dvar ## 2 = g2_write[data]; \
  240 :                   : 	prefix ## dvar ## 2c = ~g2_write[data] & G2_DATA;
  241 :                   : 
  242 :                   : // re-assemble read data
  243 :                   : #define CONV_READ_DATA(t, data, prefix, dvar) \
  244 :                   : 	t = prefix ## dvar ## 0; \
  245 :                   : 	data = ((t & BUS_LD0) >> 27) | ((t & BUS_LD3) >> 23) | ((t & BUS_LD4) >> 19); \
  246 :                   : 	t = prefix ## dvar ## 1; \
  247 :                   : 	data |= ((t & BUS_LD1) >> 13) | ((t & BUS_LD2) >> 13) | ((t & BUS_LD5) >> 7) | ((t & BUS_LD6) >> 7); \
  248 :                   : 	t = prefix ## dvar ## 2; \
  249 :                   : 	data |= ((t & BUS_LD7) << 3);	/* remember: PRU has already inverted LDn */
  250 :                   : 
  251 :                   : #define CONV_ADDR_DATA_DCL(advar) \
  252 :                   : 	u4_t _ ## advar ## 0, _ ## advar ##0c, _ ## advar ## 1, _ ## advar ## 1c, \
  253 :                   : 		_ ## advar ## 2, _ ## advar ## 2c, _ ## advar ## 3, _ ## advar ## 3c;
  254 :                   : 
  255 :                   : // pre-compute address and (write) data
  256 :                   : #define CONV_ADDR_DATA(prefix, advar, addr, data) \
  257 :                   : 	prefix ## advar ## 0  = g0_addr[addr] | g0_write[data]; \
  258 :                   : 	prefix ## advar ## 0c = (~g0_addr[addr] & G0_ADDR) | (~g0_write[data] & G0_DATA); \
  259 :                   : 	prefix ## advar ## 1  = g1_addr[addr] | g1_write[data]; \
  260 :                   : 	prefix ## advar ## 1c = (~g1_addr[addr] & G1_ADDR) | (~g1_write[data] & G1_DATA); \
  261 :                   : 	prefix ## advar ## 2  = g2_write[data]; \
  262 :                   : 	prefix ## advar ## 2c = ~g2_write[data] & G2_DATA; \
  263 :                   : 	prefix ## advar ## 3  = g3_addr[addr]; \
  264 :                   : 	prefix ## advar ## 3c = ~g3_addr[addr] & G3_ADDR;
  265 :                   : 
  266 :                   : #define CONV_ADDR_PRF(avar) \
  267 :                   : 	printf("%s: %8x %8x %8x %8x %8x %8x\n", #avar, \
  268 :                   : 		avar ## 0, avar ##0c, avar ## 1, avar ## 1c, avar ## 3, avar ## 3c);
  269 :                   : 
  270 :                   : #define CONV_ADDR_DATA_PRF(advar) \
  271 :                   : 	printf("%s: %8x %8x %8x %8x %8x %8x %8x %8x\n", #advar, \
  272 :                   : 		advar ## 0, advar ##0c, advar ## 1, advar ## 1c, advar ## 2, advar ## 2c, advar ## 3, advar ## 3c);
  273 :                   : 
  274 :                   : #ifndef HPIB_FAST_BINARY_PRU
  275 :                   : 
  276 :                   : // set pre-computed address
  277 :                   : #define SET_GPIO_ADDR(avar) \
  278 :                   : 	GPIO_CLR(0) = _ ## avar ## 0; \
  279 :                   : 	GPIO_SET(0) = _ ## avar ## 0c; \
  280 :                   : 	GPIO_CLR(1) = _ ## avar ## 1; \
  281 :                   : 	GPIO_SET(1) = _ ## avar ## 1c; \
  282 :                   : 	GPIO_CLR(3) = _ ## avar ## 3; \
  283 :                   : 	GPIO_SET(3) = _ ## avar ## 3c;
  284 :                   : 
  285 :                   : // the following way of computing 'data' doesn't work for some reason (timing marginal?)
  286 :                   : // gives occasional wrong answers with fast binary hpib transfers
  287 :                   : // but doesn't really matter since it's no faster than existing bitwise shift-and-or scheme
  288 :                   : //	data = gpio_read[((GPIO_IN(0) >> 18) | (GPIO_IN(1) >> 12) | GPIO_IN(2)) & 0x33f];
  289 :                   : 
  290 :                   : // regular full byte read
  291 :                   : #define FAST_READ_GPIO_CYCLE(avar, data) \
  292 :                   : 	SET_GPIO_ADDR(avar); \
  293 :                   : 	\
  294 :                   : 	BUS_CLK_ASSERT(); \
  295 :                   : 	GPIO_SET(0) = BUS_DIR; \
  296 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  297 :                   : 	GPIO_CLR(1) = BUS_LVMA; \
  298 :                   : 	\
  299 :                   : 	t = GPIO_IN(0); \
  300 :                   : 	data = ((t & BUS_LD0) >> 27) | ((t & BUS_LD3) >> 23) | ((t & BUS_LD4) >> 19); \
  301 :                   : 	t = GPIO_IN(1); \
  302 :                   : 	data |= ((t & BUS_LD1) >> 13) | ((t & BUS_LD2) >> 13) | ((t & BUS_LD5) >> 7) | ((t & BUS_LD6) >> 7); \
  303 :                   : 	t = GPIO_IN(2); \
  304 :                   : 	data |= ((t & BUS_LD7) << 3); \
  305 :                   : 	data = ~data & 0xff; /* remember: have to invert LDn */ \
  306 :                   : 	\
  307 :                   : 	GPIO_SET(1) = BUS_LVMA; \
  308 :                   : 	BUS_CLK_DEASSERT();
  309 :                   : 
  310 :                   : // two byte read with sequential address of addr|0, addr|1
  311 :                   : #define FAST_READ2_GPIO_CYCLE(avar, data, data2) \
  312 :                   : 	SET_GPIO_ADDR(avar); \
  313 :                   : 	\
  314 :                   : 	BUS_CLK_ASSERT(); \
  315 :                   : 	GPIO_SET(0) = BUS_DIR; \
  316 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  317 :                   : 	GPIO_CLR(1) = BUS_LVMA; \
  318 :                   : 	\
  319 :                   : 	t = GPIO_IN(0); \
  320 :                   : 	data = ((t & BUS_LD0) >> 27) | ((t & BUS_LD3) >> 23) | ((t & BUS_LD4) >> 19); \
  321 :                   : 	t = GPIO_IN(1); \
  322 :                   : 	data |= ((t & BUS_LD1) >> 13) | ((t & BUS_LD2) >> 13) | ((t & BUS_LD5) >> 7) | ((t & BUS_LD6) >> 7); \
  323 :                   : 	t = GPIO_IN(2); \
  324 :                   : 	data |= ((t & BUS_LD7) << 3); \
  325 :                   : 	data = ~data & 0xff; /* remember: have to invert LDn */ \
  326 :                   : 	BUS_CLK_DEASSERT(); \
  327 :                   : 	\
  328 :                   : 	GPIO_CLR(3) = BUS_LA0; /* bump address to avar|1 */ \
  329 :                   : 	BUS_CLK_ASSERT(); \
  330 :                   : 	t = GPIO_IN(0); /* extra delay before read of bus */ \
  331 :                   : 	t = GPIO_IN(0); \
  332 :                   : 	data2 = ((t & BUS_LD0) >> 27) | ((t & BUS_LD3) >> 23) | ((t & BUS_LD4) >> 19); \
  333 :                   : 	t = GPIO_IN(1); \
  334 :                   : 	data2 |= ((t & BUS_LD1) >> 13) | ((t & BUS_LD2) >> 13) | ((t & BUS_LD5) >> 7) | ((t & BUS_LD6) >> 7); \
  335 :                   : 	t = GPIO_IN(2); \
  336 :                   : 	data2 |= ((t & BUS_LD7) << 3); \
  337 :                   : 	data2 = ~data2 & 0xff; /* remember: have to invert LDn */ \
  338 :                   : 	BUS_CLK_DEASSERT(); \
  339 :                   : 	\
  340 :                   : 	GPIO_SET(1) = BUS_LVMA;
  341 :                   : 
  342 :                   : // read from a single gpio
  343 :                   : #define FAST_READ_GPIO1_CYCLE(gpio, data, avar) \
  344 :                   : 	SET_GPIO_ADDR(avar); \
  345 :                   : 	\
  346 :                   : 	BUS_CLK_ASSERT(); \
  347 :                   : 	GPIO_SET(0) = BUS_DIR; \
  348 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  349 :                   : 	GPIO_CLR(1) = BUS_LVMA; \
  350 :                   : 	\
  351 :                   : 	data = ~GPIO_IN(gpio); /* remember: have to invert LDn */ \
  352 :                   : 	\
  353 :                   : 	GPIO_SET(1) = BUS_LVMA; \
  354 :                   : 	BUS_CLK_DEASSERT();
  355 :                   : 
  356 :                   : // read from two gpios
  357 :                   : #define FAST_READ_GPIO2_CYCLE(gpio1, gpio2, data1, data2, avar) \
  358 :                   : 	SET_GPIO_ADDR(avar); \
  359 :                   : 	\
  360 :                   : 	BUS_CLK_ASSERT(); \
  361 :                   : 	GPIO_SET(0) = BUS_DIR; \
  362 :                   : 	GPIO_CLR(0) = BUS_LRW; \
  363 :                   : 	GPIO_CLR(1) = BUS_LVMA; \
  364 :                   : 	\
  365 :                   : 	data1 = ~GPIO_IN(gpio1); /* remember: have to invert LDn */ \
  366 :                   : 	data2 = ~GPIO_IN(gpio2); /* remember: have to invert LDn */ \
  367 :                   : 	\
  368 :                   : 	GPIO_SET(1) = BUS_LVMA; \
  369 :                   : 	BUS_CLK_DEASSERT();
  370 :                   : 
  371 :                   : // regular full byte write
  372 :                   : #define FAST_WRITE_GPIO_CYCLE(advar) \
  373 :                   : 	GPIO_CLR(0) = _ ## advar ## 0; \
  374 :                   : 	GPIO_SET(0) = _ ## advar ## 0c; \
  375 :                   : 	GPIO_CLR(1) = _ ## advar ## 1; \
  376 :                   : 	GPIO_SET(1) = _ ## advar ## 1c; \
  377 :                   : 	GPIO_CLR(2) = _ ## advar ## 2; \
  378 :                   : 	GPIO_SET(2) = _ ## advar ## 2c; \
  379 :                   : 	GPIO_CLR(3) = _ ## advar ## 3; \
  380 :                   : 	GPIO_SET(3) = _ ## advar ## 3c; \
  381 :                   : 	\
  382 :                   : 	/* pulse the bus clock */ \
  383 :                   : 	BUS_CLK_ASSERT(); \
  384 :                   : 	BUS_CLK_DEASSERT();
  385 :                   : 
  386 :                   : // write allowing each gpio set/clr to be qualified (and the 'if' optimized away since test values are constant)
  387 :                   : #define FAST_WRITE_GPIO_QUAL_CYCLE(advar, g0, g0c, g1, g1c, g2, g2c, g3, g3c) \
  388 :                   : 	if (g0) GPIO_CLR(0) = _ ## advar ## 0; \
  389 :                   : 	if (g0c) GPIO_SET(0) = _ ## advar ## 0c; \
  390 :                   : 	if (g1) GPIO_CLR(1) = _ ## advar ## 1; \
  391 :                   : 	if (g1c) GPIO_SET(1) = _ ## advar ## 1c; \
  392 :                   : 	if (g2) GPIO_CLR(2) = _ ## advar ## 2; \
  393 :                   : 	if (g2c) GPIO_SET(2) = _ ## advar ## 2c; \
  394 :                   : 	if (g3) GPIO_CLR(3) = _ ## advar ## 3; \
  395 :                   : 	if (g3c) GPIO_SET(3) = _ ## advar ## 3c; \
  396 :                   : 	\
  397 :                   : 	/* pulse the bus clock */ \
  398 :                   : 	BUS_CLK_ASSERT(); \
  399 :                   : 	BUS_CLK_DEASSERT();
  400 :                   : 
  401 :                   : #endif
  402 :                   : 
  403 :                   : void check_pmux();
  404 :                   : 
  405 :                   : #endif
  406 :                   : 
  407 :                   : #endif
  408 :                   : 

Source File 5 : 'bus.h' (No Ouput Generated)

    1 :                   : #ifndef _BUS_H_
    2 :                   : #define _BUS_H_
    3 :                   : 
    4 :                   : // bus signal mapping between microcontroller and 5370 bus for various setups
    5 :                   : // recall that the 5370 bus signals are active low and therefore named BUS_Lxxx
    6 :                   : 
    7 :                   : #ifdef SETUP_TIME_NUTS_PCB_V3
    8 :                   : 
    9 :                   : // busses are scrambled across the four gpios to make pcb layout easier
   10 :                   : 
   11 :                   : #ifndef _PASM_
   12 :                   : 	volatile u4_t *gpio0, *gpio1, *gpio2, *gpio3;
   13 :                   : 	
   14 :                   : 	#define	B0	0x01
   15 :                   : 	#define	B1	0x02
   16 :                   : 	#define	B2	0x04
   17 :                   : 	#define	B3	0x08
   18 :                   : 	#define	B4	0x10
   19 :                   : 	#define	B5	0x20
   20 :                   : 	#define	B6	0x40
   21 :                   : 	#define	B7	0x80
   22 :                   : #endif
   23 :                   : 
   24 :                   : 
   25 :                   : // on GPIO0:
   26 :                   : #define BUS_LA5		0x00000004		// 1<<2
   27 :                   : #define BUS_LA6		0x00000008		// 1<<3
   28 :                   : #define	BUS_LRW		0x00000010
   29 :                   : #define	BUS_LIRQ	0x00000020
   30 :                   : #define BUS_LA2		0x00004000		// 1<<14
   31 :                   : #define BUS_LA3		0x00008000		// 1<<15
   32 :                   : #define BUS_DIR		0x00400000		// 1 = read, direction pin on 74LVC4245 xcvr
   33 :                   : #define BUS_LD4		0x00800000		// 1<<23
   34 :                   : #define BUS_LD3		0x04000000		// 1<<26
   35 :                   : #define BUS_LD0		0x08000000		// 1<<27
   36 :                   : #define BUS_LRST	0x40000000
   37 :                   : 
   38 :                   : #define	G0_ADDR		(BUS_LA6 | BUS_LA5 | BUS_LA3 | BUS_LA2)
   39 :                   : #define	G0_DATA		(BUS_LD4 | BUS_LD3 | BUS_LD0)
   40 :                   : 
   41 :                   : #define GPIO0_AVAIL	0x80000000		// means available for our future use
   42 :                   : #define GPIO0_LCD	0x00000f00
   43 :                   : #define GPIO0_CONF	0x00003000		// cape expansion configuration EEPROM
   44 :                   : #define GPIO0_MULT	0x00100080		// multi-use pins
   45 :                   : #define GPIO0_UNK	0x332f0043		// other unknown use by BBB (not on expansion header)
   46 :                   : 
   47 :                   : 
   48 :                   : // on GPIO1:
   49 :                   : #define BUS_LD5		0x00001000		// 1<<12
   50 :                   : #define BUS_LD6		0x00002000		// 1<<13
   51 :                   : #define BUS_LD1		0x00004000		// 1<<14
   52 :                   : #define BUS_LD2		0x00008000		// 1<<15
   53 :                   : #define BUS_LA4		0x00020000		// 1<<17
   54 :                   : #define BUS_LNMI	0x00080000
   55 :                   : #define BUS_LVMA	0x20000000
   56 :                   : 
   57 :                   : #define	G1_ADDR		(BUS_LA4)
   58 :                   : #define	G1_DATA		(BUS_LD6 | BUS_LD5 | BUS_LD2 | BUS_LD1)
   59 :                   : 
   60 :                   : #define GPIO1_AVAIL	0x10050000
   61 :                   : #define GPIO1_EMMC	0xc00000ff
   62 :                   : #define GPIO1_UNK	0x0ff00f00
   63 :                   : 
   64 :                   : 
   65 :                   : // on GPIO2:
   66 :                   : #define BUS_OE		0x00000002		// 1 = Z, oe pin on 74LVC4245 xcvr
   67 :                   : #define BUS_CLK		0x00000004
   68 :                   : #define BUS_LD7		0x00000010		// 1<<4
   69 :                   : 
   70 :                   : #define	G2_DATA		(BUS_LD7)
   71 :                   : 
   72 :                   : #define GPIO2_AVAIL	0x00000028
   73 :                   : #define GPIO2_LCD	0x03e3ffc0
   74 :                   : #define GPIO2_UNK	0xfc1c0001
   75 :                   : 
   76 :                   : 
   77 :                   : // on GPIO3:
   78 :                   : #define BUS_LA0		0x00010000		// 1<<16
   79 :                   : #define BUS_LA1		0x00080000		// 1<<19
   80 :                   : 
   81 :                   : #define	G3_ADDR		(BUS_LA1 | BUS_LA0)
   82 :                   : 
   83 :                   : #define GPIO3_LCD	0x0022c000
   84 :                   : #define GPIO3_MULT	0x00140000
   85 :                   : #define GPIO3_UNK	0xffc03fff
   86 :                   : 
   87 :                   : #endif
   88 :                   : 
   89 :                   : #endif
   90 :                   : 

Source File 6 : '5370_regs.h' (No Ouput Generated)

    1 :                   : #ifndef _5370_REGS_H_
    2 :                   : #define _5370_REGS_H_
    3 :                   : 
    4 :                   : #ifndef _PASM_
    5 :                   : 
    6 :                   : #include "5370.h"
    7 :                   : 
    8 :                   : // an attempt to deal with mixed-use of register signal polarity (cure possibly worse than disease)
    9 :                   : #define	AH	0			// active high
   10 :                   : #define	AL	0x100		// active low
   11 :                   : #define	AM	0xff
   12 :                   : #define b(f, pol) 		(f | pol)
   13 :                   : #define active(f)		( ((f)&AL)? 0:(f) )			// an active active-low signal is zero
   14 :                   : #define inactive(f)		( ((f)&AL)? ((f)&AM):0 )	// an inactive active-low signal is one
   15 :                   : #define	dont_care(f)	0
   16 :                   : #define isActive(f,v)	( ((f)&AL)? (!((f)&AM&(v))) : ((f)&(v)) )
   17 :                   : #define isInactive(f,v)	( ((f)&AL)? ((f)&AM&(v)) : (!((f)&(v))) )
   18 :                   : 
   19 :                   : // interpretation of the registers and signals from the manual & schematics
   20 :                   : // corrections and improvements welcome
   21 :                   : //
   22 :                   : // registers are either read-only or write-only
   23 :                   : // [signal] is an inter-board signal name called out on the schematics
   24 :                   : //
   25 :                   : // boards:
   26 :                   : // A11 = display
   27 :                   : // A16 = arming interface
   28 :                   : // A17 = count chain
   29 :                   : // A18 = DAC, N0 logic
   30 :                   : // A22 = arming assembly
   31 :                   : //
   32 :                   : // on the A17 schematic the address signals driving the muxes are shown as: A0, LEN0, LEN1, LEN2
   33 :                   : // the correct labeling should be:  LEN0, LEN1, LEN2, A0
   34 :                   : 
   35 :                   : // read-only registers
   36 :                   : #define RREG_KEY_SCAN		ADDR_DSP(0)
   37 :                   : 
   38 :                   : #define	RREG_LDACSR			ADDR_ARM(1)	// code always seems to use (1) instead of (0)
   39 :                   : #define	DSR_TRIG_LVL_STOP	0x8			// both decode to same register
   40 :                   : #define	DSR_TRIG_LVL_START	0x4
   41 :                   : #define	DSR_SPARE			0x2			// loopback of DCW_SPARE
   42 :                   : #define	DSR_VOK				0x1			// power supply voltages check
   43 :                   : 
   44 :                   : #define	RREG_A16_SWITCHES	ADDR_ARM(2)	// 2,3 A16-U21-U15
   45 :                   : 
   46 :                   : #define	RREG_I1				ADDR_ARM(3)
   47 :                   : #define I1_IRQ				0x80		// interrupt request
   48 :                   : #define I1_RTI_MASK			0x40		// loopback of O1_RTI_MASK
   49 :                   : #define I1_RST_TEST			0x20		// loopback of O3_RST_TEST
   50 :                   : #define I1_SRATE			0x10		// sample rate
   51 :                   : #define	I1_LRMT				0x08		// loopback of O1_LRM_MASK
   52 :                   : #define I1_LRTL				0x04		// front pnl rmt/lcl key [rtn to local]
   53 :                   : #define I1_MAN_ARM			0x02		// front pnl man arm key [man arm]
   54 :                   : #define I1_IO_FLO			0x01		// driven from O2_FLAG and A11 [flag] (wire or)
   55 :                   : 
   56 :                   : #define RREG_ST				ADDR_ARM(4)	// 4,5 A17-U9-U11
   57 :                   : #define	ST_OVEN				b(0x80,AL)	// oven temp status [loven]
   58 :                   : #define	ST_EXT				b(0x40,AH)	// ext freq std [hext]
   59 :                   : 
   60 :                   : #define RREG_N0ST			ADDR_ARM(5)
   61 :                   : #define N0ST_STATUS			(~(N0ST_N0_POS | N0ST_N1N2) & 0xff)
   62 :                   : #define	N0ST_N3_OVFL		b(0x80,AH)	// event counter (N3) overflow flag [hn3or]
   63 :                   : #define	N0ST_EOM			b(0x40,AL)	// end-of-measurement [lproc]
   64 :                   : #define N0ST_N0_POS			0x20		// N0 sign [sign]
   65 :                   : #define N0ST_ARMED			0x10		// armed flag [ermd]
   66 :                   : #define N0ST_PLL_OOL		b(0x08,AH)	// PLL out-of-lock, latched [lool]
   67 :                   : #define N0ST_N0_OVFL		b(0x04,AH)	// N0 overflow flag
   68 :                   : #define N0ST_N1N2			0x03		// N1N2 bits <17,16>
   69 :                   : #define N0ST_N1N2_B17		0x02		// N1N2 bit 17
   70 :                   : #define N0ST_N1N2_B16		0x01		// N1N2 bit 16
   71 :                   : 
   72 :                   : #endif
   73 :                   : 
   74 :                   : #define	N0ST_N3_OVFL_GPIO	BUS_LD7		// gpio2
   75 :                   : #define N0ST_EOM_GPIO		BUS_LD6		// gpio1
   76 :                   : #define N0ST_PLL_OOL_GPIO	BUS_LD3
   77 :                   : #define N0ST_N0_POS_GPIO	BUS_LD5		// gpio1
   78 :                   : #define N0ST_N0_OVFL_GPIO	BUS_LD2		// gpio1
   79 :                   : #define N0ST_N1_GPIO		BUS_LD1
   80 :                   : #define N0ST_N2_GPIO		BUS_LD0
   81 :                   : 
   82 :                   : #ifndef _PASM_
   83 :                   : 
   84 :                   : // N0 is incorrectly labeled "N3 counter" on A17 schematic
   85 :                   : // N3 is used on the schematics as another name for the event counter (see below)
   86 :                   : #define RREG_N0H			ADDR_ARM(6)		// 16-bit N0 counter A17-U6-U5
   87 :                   : #define RREG_N0L			ADDR_ARM(7)
   88 :                   : 
   89 :                   : #define RREG_N1N2H			ADDR_ARM(8)		// N1N2 18-bit signed, A17-U12-U8
   90 :                   : #define RREG_N1N2L			ADDR_ARM(9)		// bits <17,16> are in N0ST <1,0>
   91 :                   : 
   92 :                   : #define RREG_N3H			ADDR_ARM(0xa)	// 16-bit event counter (AKA N3), A16-U19-U17
   93 :                   : #define RREG_N3L			ADDR_ARM(0xb)
   94 :                   : 
   95 :                   : 
   96 :                   : // write-only registers
   97 :                   : #define WREG_SPARE			ADDR_ARM(0)
   98 :                   : 
   99 :                   : #define WREG_LDACCW			ADDR_ARM(1)
  100 :                   : #define	DCW_START_DAC_OE_L	0x80
  101 :                   : #define	DCW_STOP_DAC_OE_L	0x40
  102 :                   : #define	DCW_RELAY			0x20		// 1 = DAC drives trig lvl (trig remote)
  103 :                   : #define	DCW_LOCK_FIX		0x10		// [lock fix]
  104 :                   : #define	DCW_SPARE			0x08
  105 :                   : #define	DCW_HRMT_SLOPE		0x04		// [hrmt slope]
  106 :                   : #define	DCW_FWD_REV_START	0x02
  107 :                   : #define	DCW_FWD_REV_STOP	0x01
  108 :                   : 
  109 :                   : #define WREG_LDACSTART		ADDR_ARM(2)
  110 :                   : #define WREG_LDACSTOP		ADDR_ARM(3)
  111 :                   : 
  112 :                   : // most of these are signals going to the A22 arming assembly
  113 :                   : #define WREG_O2				ADDR_ARM(4)	// A16-U3-U9
  114 :                   : #define O2_FLAG				b(0x80,AH)	// [flag]
  115 :                   : #define O2_SRATE_EN			b(0x40,AH)	// sample rate enable
  116 :                   : #define O2_HTOGL			b(0x20,AH)	// [htogl]
  117 :                   : #define O2_GATE_MODE		b(0x10,AL)	// [lgate] 0 = gate time mode (freq/period) or ext holdoff
  118 :                   : #define O2_HARMCT3			b(0x08,AH)	// [harmct3]
  119 :                   : #define O2_ARM_MODE			b(0x04,AH)	// [larmct2] 0: arm=start/stop 1: arm=man/ext
  120 :                   : #define O2_MAN_ARM			b(0x02,AH)	// manual arm [hmnrm]
  121 :                   : #define O2_ARM_EN			b(0x01,AH)	// arm enable [harmen/lrst]
  122 :                   : 
  123 :                   : #define WREG_O2_IDLE_GOOD	0x94
  124 :                   : #define WREG_O2_IDLE	( \
  125 :                   : 	active(O2_FLAG) | active(O2_ARM_MODE) | \
  126 :                   : 	inactive(O2_SRATE_EN) | inactive(O2_HTOGL) | inactive(O2_GATE_MODE) | inactive(O2_HARMCT3) | inactive(O2_MAN_ARM) | inactive(O2_ARM_EN) \
  127 :                   : )
  128 :                   : 
  129 :                   : #define WREG_O2_ENA_GOOD	0x95
  130 :                   : #define WREG_O2_ENA	( \
  131 :                   : 	active(O2_FLAG) | active(O2_ARM_MODE) | active(O2_ARM_EN) | \
  132 :                   : 	inactive(O2_SRATE_EN) | inactive(O2_HTOGL) | inactive(O2_GATE_MODE) | inactive(O2_HARMCT3) | inactive(O2_MAN_ARM) \
  133 :                   : )
  134 :                   : 
  135 :                   : #define WREG_O2_ARM_GOOD	0x97
  136 :                   : #define WREG_O2_ARM	( \
  137 :                   : 	active(O2_FLAG) | active(O2_ARM_MODE) | active(O2_ARM_EN) | active(O2_MAN_ARM) | \
  138 :                   : 	inactive(O2_SRATE_EN) | inactive(O2_HTOGL) | inactive(O2_GATE_MODE) | inactive(O2_HARMCT3) \
  139 :                   : )
  140 :                   : 
  141 :                   : // most of these are signals going to the A22 arming assembly
  142 :                   : #define WREG_O1				ADDR_ARM(5)	// A16-U2-U7
  143 :                   : #define O1_LRM_MASK			0x80		// [lrm mask]
  144 :                   : #define O1_RTI_MASK			0x40		// 1 = enable RTI/IRQ (interrupt)
  145 :                   : #define O1_LHLDEN			0x20		// [lhlden]
  146 :                   : #define O1_STOPSW			0x10		// [stopsw]
  147 :                   : #define O1_STARTSW			0x08		// [startsw]
  148 :                   : #define O1_HSET2			0x04		// [hset2]
  149 :                   : #define O1_HSET1			0x02		// [hset1]
  150 :                   : #define O1_HSTD				0x01		// [hstd]
  151 :                   : 
  152 :                   : // This register has the feature that it will self-clear on the next clock cycle
  153 :                   : // if the O3_SELF_CLR bit is asserted (active low). Hence a pulse of the other
  154 :                   : // simultaneously asserted signals will be generated without further software intervention.
  155 :                   : #define WREG_O3				ADDR_ARM(6)	// A16-U5-U11
  156 :                   : #define O3_SELF_CLR			b(0x80,AL)	// clear this reg on next phase-2 clk
  157 :                   : #define O3_RST_TEST			b(0x40,AL)	// loopback to I1_RST_TEST
  158 :                   : #define O3_LARMRST			b(0x20,AL)	// [larmrst] arm assy master reset (called preset on A22)
  159 :                   : #define O3_LOLRST			b(0x10,AL)	// [a16:lpolrst, a17:lolrst] PLL loss-of-lock FF reset
  160 :                   : #define O3_N3_OVRST			b(0x08,AL)	// clr event ctr ovfl flag on A16, the output of which is [hn3or]
  161 :                   : #define O3_N0_OVRST			b(0x04,AL)	// [a16:lpor0st, a17:lorst] pulse overrange N0 reset, happens when bit 15 of N0 is set. ovfl cnt kept in software.
  162 :                   : #define O3_N3_RST			b(0x02,AL)	// (signal inverted) [hn3rst] event ctr (N3) reset A16 and A22
  163 :                   : #define O3_N012_RST			b(0x01,AL)	// [a16:lpcrst, a17:lcrst] pulse counter reset, resets all ctrs on A17: N0, N1, N2
  164 :                   : 
  165 :                   : #endif
  166 :                   : 
  167 :                   : #define O3_N3_OVRST_GPIO	BUS_LD3		// gpio0
  168 :                   : #define O3_N0_OVRST_GPIO	BUS_LD2		// gpio1
  169 :                   : 
  170 :                   : #ifndef _PASM_
  171 :                   : 
  172 :                   : #define WREG_O3_RST_GOOD	0x5a
  173 :                   : #define WREG_O3_RST	( \
  174 :                   : 	active(O3_SELF_CLR) | active(O3_LARMRST) | active(O3_N0_OVRST) | active(O3_N012_RST) | \
  175 :                   : 	inactive(O3_RST_TEST) | inactive(O3_LOLRST) | inactive(O3_N3_OVRST) | inactive(O3_N3_RST) \
  176 :                   : )
  177 :                   : 
  178 :                   : #define WREG_O3_N0_CLR_OVFL	( \
  179 :                   : 	active(O3_SELF_CLR) | active(O3_N0_OVRST) | \
  180 :                   : 	inactive(O3_LARMRST) | inactive(O3_N012_RST) | inactive(O3_RST_TEST) | inactive(O3_LOLRST) | inactive(O3_N3_OVRST) | inactive(O3_N3_RST) \
  181 :                   : )
  182 :                   : 
  183 :                   : #define WREG_O3_N3_CLR_OVFL	( \
  184 :                   : 	active(O3_SELF_CLR) | active(O3_N3_OVRST) | \
  185 :                   : 	inactive(O3_LARMRST) | inactive(O3_N012_RST) | inactive(O3_RST_TEST) | inactive(O3_LOLRST) | inactive(O3_N0_OVRST) | inactive(O3_N3_RST) \
  186 :                   : )
  187 :                   : 
  188 :                   : #endif
  189 :                   : 
  190 :                   : #endif
  191 :                   : 

